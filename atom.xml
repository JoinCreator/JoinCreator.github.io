<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2022-04-03T00:49:16.023Z</updated>
  <id>/</id>
  
  <author>
    <name>ZHANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础</title>
    <link href="/2022/04/03/java%E5%9F%BA%E7%A1%80/"/>
    <id>/2022/04/03/java基础/</id>
    <published>2022-04-03T00:44:22.314Z</published>
    <updated>2022-04-03T00:49:16.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><h1 id="一、java特点"><a href="#一、java特点" class="headerlink" title="一、java特点"></a>一、java特点</h1><pre><code>1、java语言是面向对象的（oop）2、java语言是健壮性的，Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证3、 Java 语言是 跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]4、 Java 语言是解释型的[了解]解释性语言：javascript,PHP, java 编译性语言: c / c++区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c++</code></pre><h2 id="JDK-基本介绍"><a href="#JDK-基本介绍" class="headerlink" title="JDK 基本介绍"></a>JDK 基本介绍</h2><pre><code>JDK 的全称(Java Development Kit Java 开发工具包)JDK = JRE + java 的开发工具 [java, javac,javadoc,javap 等]JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK 中.2) JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。JRE 基本介绍1) JRE(Java Runtime Environment Java 运行环境)JRE = JVM + Java 的核心类库[类]2) 包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。JDK、JRE 和 JVM 的包含关系1) JDK = JRE + 开发工具集（例如 Javac,java 编译工具等)2) JRE = JVM + Java SE 标准类库（java 核心类库）3) 如果只想运行开发好的 .class 文件 只需要 JRE</code></pre><p>安装jdk配置环境变量</p><p><img src="images\图片.png" style="zoom: 50%;"></p><p>java程序运行流程</p><p><img src="images\java运行流程.png" alt></p><h2 id="Java-开发注意事项和细节"><a href="#Java-开发注意事项和细节" class="headerlink" title="Java 开发注意事项和细节"></a>Java 开发注意事项和细节</h2><pre><code class="java">1. Java源文件以 java为扩展名。源文件的基本组成部分是类(class) ， 如本类中的Hello   类。2. Java应用程序的执行入口是main(方法。它有固定的书写格式:   public static void main(String[ args) {...}3. Java语言严格区分大小写.4. Java方法由一条条语句构成，每个语句以“,&quot; 结束。5.大括号都是成对出现的，缺一不可。 [习惯， 先写{}再写代码]6.一个源文件中最多只能有一个public类。其它类的个数不限。7.如果源文件包含一个public类， 则文件名必须按该类名命名! 8.一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public 类，这样入口方法就是非public的main方法</code></pre><h2 id="Java-转义字符"><a href="#Java-转义字符" class="headerlink" title="Java 转义字符"></a>Java 转义字符</h2><h3 id="Java-常用的转义字符"><a href="#Java-常用的转义字符" class="headerlink" title="Java 常用的转义字符"></a>Java 常用的转义字符</h3><pre><code class="java">在控制台，输入 tab 键，可以实现命令补全&quot;\“代表转义符\t ：一个制表位，实现对齐的功能\n ：换行符\\ \：表示一个\\\ &quot; :一个&quot;\\ &#39;：一个&#39;\r :一个回车 </code></pre><h3 id="注释-comment"><a href="#注释-comment" class="headerlink" title="注释(comment)"></a>注释(comment)</h3><pre><code class="java">用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。 [举例]1) 单行注释 //2) 多行注释 /* */3) 文档注释 /** */</code></pre><h2 id="常用的-dos-命令"><a href="#常用的-dos-命令" class="headerlink" title="常用的 dos 命令"></a>常用的 dos 命令</h2><pre><code class="java">1) 查看当前目录是有什么内容 dir   dir dir d:\abc2\test2002) 切换到其他盘下：盘符号 cd : change directory   案例演示：切换到 c 盘 cd /D c:3) 切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\表示上一级目录   案例演示： cd d:\abc2\test200 cd ..\..\abc2\test2004) 切换到上一级：   案例演示： cd ..5) 切换到根目录：cd \   案例演示：cd \6) 查看指定的目录下所有的子级目录 tree7) 清屏 cls [苍老师]8) 退出 DOS exit9) 说明: (md[创建目录],rd[删除目录],copy[拷贝文件],del[删除文件],echo[输入内容到文件],type,move[剪切]) =&gt; Linux,</code></pre><h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过 门牌号我们可以找到房间，而通过变量名可以访问到变量(值)。</code></pre><p>变量使用的基本步骤</p><pre><code class="java">变量必须先声明在使用1) 声明变量   int a;2) 赋值   a = 60; // 把 60 赋给 a   使用 System.out.println(a);   //也可以一步到位[int a = 60; 通常我们是一步完成]</code></pre><h2 id="变量使用注意事项"><a href="#变量使用注意事项" class="headerlink" title="变量使用注意事项"></a>变量使用注意事项</h2><pre><code>1.变量表示内存中的一个存储区域[不同的变量，类型不同，占用的空间大小不同，比如: int 4个字节，double 就是8个字节]2.该区域有自己的名称[安量名]和类型[数据类型]3.变量必须先声明，后使用，即有顺序4.该区域的数据/值可以在同一类型范围内不断变化5.变量在同一个作用域内不能重名6.变量=变量名+值+数据类型。变量三要素</code></pre><h1 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h1><p>每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数型："><a href="#整数型：" class="headerlink" title="整数型："></a>整数型：</h3><pre><code class="java">基本数据类型：byte[1], 范围 （-128 ~ 127）short[2], 范围 -2^15 ~ 2^15-1 （-32768-32767）int[4], 范围 -2^31 ~ 2^31-1  (-2147483648-2147483647)long[8], 范围 -2^63 ~ 2^63-1## 引用数据类型：类：closs接口：interface数组：[...]</code></pre><h3 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h3><pre><code class="java">   float[4],double[8]1) 关于浮点数在机器中存放形式的简单说明,浮点数=符号位+指数位+尾数位2) 尾数部分可能丢失，造成精度损失(小数都是近似值)。   通常情况下使用double类型 及缴纳更多更高   1.与整数类型类似，Java 浮点类型也有固定的范围和字段长度，不受具体OS的   影响。[float 4个字节double是8个字节]2. Java 的浮点型常量(具体值)默认为double型，声明float型常量， 须后加&#39;f&#39;   或&#39;F&#39;   3.浮点型常量有两种表示形式   十进制数形式:如: 5.12  512.0f  .512 (必须有小数点)   科学计数法形式:如: 5.12e2 [5.12*10的2次方] 5.12E-2 [5.12/10的2次方]   4.通常情况下，应该使用double型，因为它比float型更精确。[举例说明]   double num9 = 2.1234567851;   float num10 = 2.1234567851F;   5.浮点数使用陷阱:2.7和8.1 / 3比较   double num7 = 2.7;   double num8=8.1/ 3;   if Math.abs(num7 - num8) &lt; .00001)[   System out. orintln(&quot;相等一):</code></pre><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型:"></a>字符型:</h3><pre><code class="java"> char[2]字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 Stringan[1]//在 java 中，char 的本质是一个整数，在默认输出时，是 unicode 码对应的字符//要输出对应的数字，可以(int)字符//char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码.</code></pre><pre><code class="java">1.字符常量是用单引号(”)括起来的单个字符。例如:charc1 = &#39;a&#39;; charc2 = &#39;中&#39;; charc3 = &#39;9&#39;;2. Java中还允许使用转义字符T来将其后的字符转变为特殊字符型常量。例如: charc3 = In&#39; ; // &quot;\n&#39;表示换行符3.在java中， char的本质是个整数，在输出时，是unicode码对应的字符。   http://tool.chinaz.com/ Tools/Unicode.aspx4.可以直接给char一个整数，然后输出时，会按照对应 的unicode字符输出[97-》a]3. char类型是可以进行运算的， 相当于一个整数， 因为它   都对应有Unicode码. </code></pre><h3 id="布尔类型："><a href="#布尔类型：" class="headerlink" title="布尔类型："></a>布尔类型：</h3><pre><code class="java">boolean[1]1.布尔类型也叫boolean类型，booolean类型数据只允许取值true和false,无null2. boolean类型占1个字节。3. boolean 类型适于逻辑运算，一般用于程序流程控制:   1 if条件控制语句;   V while循环控制语句;   V do-while循环控制语句;   V for循环控制语句</code></pre><h2 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h2><h3 id="自动类型转换："><a href="#自动类型转换：" class="headerlink" title="自动类型转换："></a>自动类型转换：</h3><p>V介绍<br>当java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，<br>这个就是自动类型转换<br>1数据类型按精度(容量)大小排序为(背会)</p><pre><code>char --&gt; int --&gt; long--&gt; float--&gt; double byte--&gt; short--&gt; int--&gt; long--&gt; float--&gt; double</code></pre><p> 自动类型转换注意和细节:</p><pre><code class="java">1.有多种类型的混合数据运算时，系统首先自动将所有数据转换成最大容量的那种数据类型，然后进行计算。2.当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换。3.（byte，short）和char之间不会相互自动转换4.byte，short,char 他们三者可以计算，在计算时首先转换为int类型。5.boolean 不参与转换6.自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</code></pre><h3 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h3><p>介绍<br>自动类型转换的逆过程， 将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成精度降低或溢出,格外要注意</p><pre><code class="java">int i= (int)1.9;System.out.println(i);int j=100;byte b=(byte)j;System.out.println(b);</code></pre><p> 强制类型转换细节:</p><pre><code class="java">1.当进行数据的大小从大&gt; 小，就需要使用到强制转换2.强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级//intx = (int)10*3.5+6*1.5;inty = (int)(10*3.5+6*1.5);System.out.println(y); 3. char类型可以保存int的常量值，但不能保存int的变量值，需要强转   charc1 = 100; //ok   int m = 100; //ok   char c2 = m; //错误   char c3=(char)m //ok   System.out. rintnt(3//100对应的字符4. byte和short, char类型在进行运算时，当做int类型处理。</code></pre><h2 id="基本数据类型转String"><a href="#基本数据类型转String" class="headerlink" title="基本数据类型转String"></a>基本数据类型转String</h2><pre><code class="java">在程序开发中，我们经常需要将基本数据类型转成String类型。或者将String类 型转成基本数据类型。1、基本数据类型转换为String类型语法：将基本数据类型+” “即可2、String类型转换为基本数据类型使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型语法：通过剧本类型的包装类调用parsexxx方法即可// 怎么把字符串转成字符 char -&gt; 指 含义是指 把字符串的第一个字符得到//解读 s5.charAt(0) 得到 s5 字符串的第一个字符 &#39;1&#39; 注意事项:1) 在将 String 类型转成 基本数据类型时， ，比如 我们可以把 &quot;123&quot; , 转成一   个整数，但是不能把 &quot;hello&quot; 转成一个整数2) 如果格式不正确，就会 抛出异常，程序就会终止</code></pre><h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><p>运算符介绍<br>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。</p><p><img src="images\算术运算符.jpg" alt="算术运算符"></p><pre><code class="java">细节说明:1.对于除号&quot;/&quot;,它的整数除和小数除是有区别的:整数之间做除法时，只保留整数部分而舍弃小数部分。例如: intx= 10/3 ,结果是32.当对一个数取模时，可以等价a%b=a-a/b*b，这样我们可以看到取模的-一个本质运算。3.当自增当做一个独立语言使用时，不管是++i;还是i++;都是一样的，等价4.当自增当做一个表达式使用时j = ++i等价[?]5.当自增当做一个表达式使用时j = i++等价[2]// % 取模 ,取余// 在 % 的本质 看一个公式!!!! a % b = a - a / b * b// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1// -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1</code></pre><pre><code class="java">前++：++i 先自增后赋值后++：i++先赋值后自增面试题1int i= 1;//i-&gt; 1i=i+ +; //规则使用临时变量: (1) temp=i;(2) i=i+ 1:(3)i=temp:System.out.println(); // 1问:结果是多少?为什么?面试题2int i=1;i=+ +i; //规则使用临时变量: (1) i=i+ 1;(2) temp=i;(3)i= temp;System.out.println(i); //2</code></pre><pre><code class="java">练习：1) 假如还有 59 天放假，问：合 xx 个星期零 xx 天2) 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。   [234.5]//编写一个 main 方法public static void main(String[] args) {//1.需求://假如还有 59 天放假，问：合 xx 个星期零 xx 天//2.思路分析//(1) 使用 int 变量 days 保存 天数//(2) 一个星期是 7 天 星期数 weeks： days / 7 零 xx 天 leftDays days % 7//(3) 输出//3.走代码int days = 25911;int weeks = days / 7;int leftDays = days % 7;System.out.println(days + &quot;天 合&quot; + weeks + &quot;星期零&quot;+ leftDays + &quot;天&quot;);  //1.需求  //定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为  //：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度  //  //2 思路分析  //(1) 先定义一个 double huaShi 变量保存 华氏温度  //(2) 根据给出的公式，进行计算即可 5/9*(华氏温度-100)  // 考虑数学公式和 java 语言的特性  //(3) 将得到的结果保存到 double sheShi  //3 走代码  double huaShi = 1234.6;  double sheShi = 5.0 / 9 * (huaShi - 100);  System.out.println(&quot;华氏温度&quot; + huaShi+ &quot; 对应的摄氏温度=&quot; + sheShi);  }</code></pre><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符就是将某个运算后的值，赋给指定的变量。</p><pre><code class="java">赋值运算符的分类 基本赋值运算符 =      int a = 10; 复合赋值运算符+= ，-= ，*= ， /= ，%= 等 , 重点讲解一个 += ，其它的使用是一个道理a += b; [等价 a = a + b; ]a -= b; [等价 a = a - b; ]</code></pre><p>assign ： 分配，指派，賦值</p><p>赋值运算符特点</p><pre><code class="java">1) 运算顺序从右往左 int num = a + b + c;2) 赋值运算符的左边 只能是变量,右边 可以是变量、表达式、常量值   int num = 20; int num2= 78 * 34 - 10; int num3 = a;3) 复合赋值运算符等价于下面的效果   比如：a+=3;等价于 a=a+3; 其他类推4) 复合赋值运算符会进行类型转换。   byte b = 2; b+=3; b++;</code></pre><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><pre><code class="java"> [比较运算符]1) 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false2) 关系表达式 经常用在 if 结构的条件中或循环结构的条件中</code></pre><p><img src="\images\关系运算符.png" alt="关系运算符"></p><pre><code class="java">细节说明1) 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。2) 关系运算符组成的表达式，我们称为关系表达式。 a &gt; b3) 比较运算符&quot;==&quot;不能误写成&quot;=&quot;</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><pre><code class="java">用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值。1) 短路与 &amp;&amp; ， 短路或 ||，取反 !2) 逻辑与 &amp;，逻辑或 |，^ 逻辑异或</code></pre><p><img src="images\逻辑运算符.jpg" alt="逻辑运算符"></p><p>说明逻辑运算规则：</p><pre><code class="java">1) a&amp;b : &amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false2) a&amp;&amp;b : &amp;&amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false3) a|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false4) a||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false5) !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true6) a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false</code></pre><p>&amp;&amp; 和 &amp; 基本规则</p><pre><code class="java">名称          语法               特点短路与&amp;&amp;   条件 1&amp;&amp;条件 2         两个条件都为 true，结果为 true,否则 false逻辑与&amp;     条件 1&amp;条件 2         两个条件都为 true，结果为 true,否则 false</code></pre><p>&amp;&amp; 和 &amp; 使用区别</p><pre><code class="java">1) &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高2) &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低3) 开发中， 我们使用的基本是使用短路与&amp;&amp;, 效率高</code></pre><p>|| 和 | 基本规则</p><pre><code class="java">名称          语法               特点短路或||     条件 1||条件 2         两个条件中只要有一个成立，结果为 true,否则为 false|逻辑或     条件 1|条件 2         只要有一个条件成立，结果为 true,否则为 false</code></pre><p>|| 和 | 使用区别</p><pre><code class="java">1) ||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高2) | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低3) 开发中，我们基本使用 ||</code></pre><p> 取反 基本规则</p><pre><code class="java">名称               语法       特点! 非（取反）     !条件     如果条件本身成立，结果为 false，否则为 true</code></pre><pre><code class="java">//!和^案例演示public class InverseOperator {//编写一个 main 方法public static void main(String[] args) {//! 操作是取反 T-&gt;F , F -&gt; TSystem.out.println(60 &gt; 20); //TSystem.out.println(!(60 &gt; 20)); //F//a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 falseboolean b = (10 &gt; 1) ^ ( 3 &gt; 5);System.out.println(&quot;b=&quot; + b);//T}}</code></pre><pre><code class="java"> ^ 案例演示a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false^逻辑异或，System.out.println( (4 &lt; 1) ^ (6 &gt; 3) ); // ?</code></pre><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法</p><pre><code class="java">条件表达式 ? 表达式 1: 表达式 2;运算规则：1. 如果条件表达式为 true，运算后的结果是表达式 1；2. 如果条件表达式为 false，运算后的结果是表达式 2；   口诀: [一灯大师：一真大师]</code></pre><p>使用细节 </p><pre><code class="java">表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)三元运算符可以转成 if--else 语句int res = a &gt; b ? a++ : --b;if ( a &gt; b) res = a++;else res = --b;</code></pre><pre><code class="java">//三元运算符细节public class TernaryOperatorDetail {//编写一个 main 方法public static void main(String[] args) {//表达式 1 和表达式 2 要为可以赋给接收变量的类型//(或可以自动转换/或者强制转换)int a = 3;int b = 8;int c = a &gt; b ? (int)1.1 : (int)3.4;//可以的double d = a &gt; b ? a : b + 3;//可以的，满足 int -&gt; double}}</code></pre><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><pre><code class="java">1) 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。2) 只有单目运算符、赋值运算符是从右向左运算的。3) 一览表, 不要背，使用多了，就熟悉了.</code></pre><p><img src="\images\运算符优先级.jpg" alt="优先级"></p><h2 id="标识符的命名"><a href="#标识符的命名" class="headerlink" title="标识符的命名"></a>标识符的命名</h2><p>规则和 规范</p><pre><code class="java">标识符概念：1. Java对各种变量、方法和类等命名时使用的字符序列称为标识符2. 凡是自己可以起名字的地方都叫标识符int num1 = 90;   , 标识符的命名规则(必须遵守)   .由26个英文字母大小写，0-9，或$组成3. 数字不可以开头。 int 3ab = 1;//错误4. 不可以使用关键字和保留字，但能包含关键字和保留字。   Java中严格区分大小写，长度无限制。int totalNum = 10; intn = 90;   5.   标识符不能包含空格。intab = 90;</code></pre><p>标识符命名规范[更加专业]</p><pre><code class="java">1) 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm2) 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]   比如： TankShotGame3) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]   比如： tankShotGame4) 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ   比如 ：定义一个所得税率 TAX_RATE</code></pre><p>关键字</p><pre><code class="java">关键字的定义和特点 ( 不用背)定义：被 Java 语言赋予了特殊含义，用做 专门用途的字符串（单词）特点：关键字中所有字母都为小写</code></pre><p><img src="images\关键字.jpg" alt></p><p>保留字</p><pre><code class="java">4.10.1 介绍Java 保留字：现有 Java 版本 尚未使用，但 以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const</code></pre><p> 键盘输入语句</p><pre><code class="java"> 介绍在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是Scanner     mport java.util.Scanner;//表示把 java.util 下的 Scanner 类导入//2. 创建 Scanner 对象 , new 创建一个对象,体会// myScanner 就是 Scanner 类的对象   Scanner myScanner = new Scanner(System.in);//当程序执行到 next 方法时，会等待用户输入~~~String name = myScanner.next(); //接收用户输入字符串int age = myScanner.nextInt(); //接收用户输入 intdouble sal = myScanner.nextDouble(); //接收用户输入 double</code></pre><h1 id="五、进制"><a href="#五、进制" class="headerlink" title="五、进制"></a>五、进制</h1><h2 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h2><pre><code class="java"> 进制介绍对于整数，有四种表示方式：二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。十进制：0-9 ，满 10 进 1。八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 或 0X 开头表示。此处的 A-F 不区分大小写。</code></pre><p><img src="images\进制01.jpg" alt></p><p><img src="images\进制02.jpg" alt></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><pre><code class="java"> 第一组：1) 二进制转十进制规则:从最低位(右边)开始，将每个位上的数提取出来，乘以2的(位数-1)次方，然后求和。案例:请将0b1011转成十进制的数0b1011 = 1*2的(1-1)次方+ 1 * 2的(2-1)次方+ 0 * 2的(3-1)次方+ 1*2的(4-1)次方法= 1 + 2 + 0+ 8= 112) 八进制转十进制    规则:从最低位(右边)开始，将每个位上的数提取出来，乘以8的(位数-1)次方,然后求和。案例:请将0234转成十进制的数0234= 4*8^0+3*8^1+2*8^2-4+ 24+128= 1563) 十六进制转十进制    规则：从最低位(右边)开始，将每个位上的数提取出来，乘以 16 的(位数-1)次方，然后求和。案例：请将 0x23A 转成十进制的数0x23A= 10 * 16^0 + 3 * 16 ^ 1 + 2 * 16^2 = 10 + 48 + 512 = 570课堂练习：请将0b110001100 转成 十进制02456 转成十进制0xA45 转成十进制第二组：4) 十进制转二进制    规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。案例：请将 34 转成二进制 = 0B001000105) 十进制转八进制    规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。案例：请将 131 转成八进制 =&gt; 02036) 十进制转十六进制第三组7) 二进制转八进制规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。案例：请将 ob11010101 转成八进制ob11(3)010(2)101(5) =&gt; 03258) 二进制转十六进制规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。案例：请将 ob11010101 转成十六进制ob1101(D)0101(5) = 0xD5课堂练习：请将0b11100101 转成 八进制0b1110010110 转成 十六进制第四组9) 八进制转二进制    规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。案例：请将 0237 转成二进制02(010)3(011)7(111) = 0b1001111110) 十六进制转二进制    规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。案例：请将 0x23B 转成二进制0x2(0010)3(0011)B(1011) = 0b001000111011练习：请将01230 转成 二进制0xAB29 转成二进制</code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><pre><code class="java">1) 请看下面的代码段，回答 a,b,c,d,e 结果是多少?   public static void maiin(String []args)   {   int a=1&gt;&gt;2; // 1 向右位移 2 位   int b=-1&gt;&gt;2;//算术右移   int c=1&lt;&lt;2;//算术左移   int d=-1&lt;&lt;2;//   int e=3&gt;&gt;&gt;2;//无符号右移   //a,b,c,d,e 结果是多少   System.out.println(&quot;a=&quot;+a);   System.out.println(&quot;b=&quot;+b);   System.out.println(&quot;c=&quot;+c);   System.out.println(&quot;d=&quot;+d);   System.out.println(&quot;e=&quot;+e);   }2) 请回答在 java 中，下面的表达式运算的结果是: (位操作)， 晚上练习   ~2=? // 按位取反    //推到    //1.得到2的源码 00000000 00000000 00000000 00000010    //2.~2操作     11111111 11111111 11111111 11111101 运算后的补码    //3.运算后的反码 11111111 11111111 11111111 11111100    //4.运算后的源码 10000000 00000000 00000000 00000011 =》-3   2&amp;3=?// 2 按位与 3   2|3=? //2按位或3   ~-5=? //   13&amp;7=?   5|4=?    -3^3=?//^ 按位异或</code></pre><p>二进制在运算中的说明</p><pre><code class="java">1.二进制是逢2进位的进位制，0、1是基本算符。2.现代的电子计算机技术全部采用的是进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制数来表示的。二进制(Binary) 数用0和1两个数字及其组合来表示任何数。进位规则是&quot;逢2进1&quot;,数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增</code></pre><p> 原码、反码、补码(重点 难点)</p><pre><code class="java">原码，反码,补码的解释(背下来）对于有符号的而言:1.二进制的最高位是符号位: 0表示正数，1表示负数(老韩口诀: 0-&gt;0 1-&gt; -) 2.正数的原码，反码，补码都样(三码合一)3.负数的反码=它的原码符号位不变，其它位取反(0-&gt;1,1-&gt;0) 4.负数的补码=它的反码+1，负数的反码=负数的补码- 15.0的反码，补码都是06. java没有无符号数，换言之，java中的数都是有符号的7.在计算机运算的时候，都是以补码的方式来运算的8.当我们看运算结果的时候，要看他的原码(重点)</code></pre><p>位运算符</p><p> java 中有 7 个位运算(&amp;、|、^、~、&gt;&gt;、&lt;&lt;和 &gt;&gt;&gt;)</p><pre><code class="java">分别是按位与&amp;、按位或|、按位异或^ ,按位取反~ ,它们的运算规则是:按位与&amp; ：两位全为1,结果为1，否则为0按位或| ：两位有一个为1,结果为1,否则为0按位异或^ : 两位一个为0,一个为1,结果为1,否则为0按位取反~ : 0-&gt;1 ,1-&gt;0 比如: 2&amp;3=?    ~-2 = ?     ~2=?    2|3=?    2^3=?</code></pre><p>还有 3 个位运算符 &gt;&gt;、&lt;&lt; 和 &gt;&gt;&gt; , 运算规则:</p><pre><code class="java">1. 算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位2. 算术左移 &lt;&lt;: 符号位不变,低位补 03. &gt;&gt;&gt; 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 04. 特别说明：没有 &lt;&lt;&lt; 符号1) int a=1&gt;&gt;2; //1 =&gt; 00000001 =&gt; 00000000 本质 1 / 2 / 2 =02) int c=1&lt;&lt;2; //1 =&gt; 00000001 =&gt; 00000100 本质 1 * 2 * 2 = 4</code></pre><h1 id="六、程序控制结构"><a href="#六、程序控制结构" class="headerlink" title="六、程序控制结构"></a>六、程序控制结构</h1><pre><code>在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句。1) 顺序控制2) 分支控制3) 循环控制</code></pre><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><pre><code class="java">程序从上到下逐行执行，中间没有任何判断和跳转。java中定义变量时采用向前引用：即先定义后使用</code></pre><h2 id="分支控制-if-else"><a href="#分支控制-if-else" class="headerlink" title="分支控制 if-else"></a>分支控制 if-else</h2><pre><code class="JAVA">分支控制 if-else 让程序有选择的的执行,分支控制有三种1) 单分支 if2) 双分支 if-else3) 多分支 if-else if -....-else</code></pre><p>单分支</p><pre><code class="java">基本语法if(条件表达式){​        执行代码块；}当条件表达式为true是，就会执行{ }中的代码。如果为false，就不执行。</code></pre><p>双分支</p><pre><code class="java">基本语法if(条件表达式){    执行代码块； }else{    执行代码块2；}当条件表达式成立时，即执行代码块1，否则执行代码块2</code></pre><p>多分支</p><pre><code class="java">基本语法if(条件表达式1){    执行代码块； }else if(条件表达式1){    执行代码块2；}......else{    执行代码块n;}如果没有else，如果所有条件表达式都不成立，则一个直行入口都没有如果有else，如果所有条件表达式都不成立，则默认执行else代码块   </code></pre><h2 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h2><p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支。建议: 不要超过 3 层 （可读性不好）</p><pre><code class="java">基本语法if(){    if(){        //if-else...    }else{        //if-else    }}</code></pre><p>应用案例<br>参加歌手比赛，如果初赛成绩大于 8.0 进入决赛，否则提示淘汰。并且根据性别提示进入男子组或女子组。【可以<br>让学员先练习下】, 输入成绩和性别，进行判断和输出信息。[NestedIf.java]</p><pre><code class="java">提示: double score; char gender;接收字符: char gender = scanner.next().charAt(0)import java.util.Scanner;public class NestedIf {//编写一个 main 方法public static void main(String[] args) {/*参加歌手比赛，如果初赛成绩大于 8.0 进入决赛，否则提示淘汰。并且根据性别提示进入男子组或女子组。【可以让学员先练习下】, 输入成绩和性别，进行判断和输出信息。[NestedIf.java]提示: double score; char gender;接收字符: char gender = scanner.next().charAt(0)*///思路分析//1. 创建 Scanner 对象，接收用户输入//2. 接收 成绩保存到 double score//3. 使用 if-else 判断 如果初赛成绩大于 8.0 进入决赛，否则提示淘汰//4. 如果进入到 决赛，再接收 char gender, 使用 if-else 输出信息//代码实现 =&gt; 思路 --&gt; java 代码Scanner myScanner = new Scanner(System.in);System.out.println(&quot;请输入该歌手的成绩&quot;);double score = myScanner.nextDouble();if( score &gt; 8.0 ) {System.out.println(&quot;请输入性别&quot;);char gender = myScanner.next().charAt(0);if( gender == &#39;男&#39; ) {System.out.println(&quot;进入男子组&quot;);} else if(gender == &#39;女&#39;) {System.out.println(&quot;进入女子组&quot;);} else {System.out.println(&quot;你的性别有误，不能参加决赛~&quot;);}} else {System.out.println(&quot;sorry ,你被淘汰了~&quot;);}}}</code></pre><h2 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h2><pre><code class="java">基本语法switch(表达式){    case 常量1：    代码块1；    break；    case 常量2：    代码块2;    break;    ......    default:    代码块；    break；}1. switch关键字，表示swtich分支2.表达式对应个值3. case常量1 :当表达式的值等于常量1,就执行语句块14. break :表示退出swtich5.如果和case常量1匹配，就执行语句块1,如果没有匹配，就继续匹配case常量26.如果一一个都没有匹配上，执行default</code></pre><p>switch 注意事项和细节讨论</p><pre><code class="java">1.表达式数据类型，应和case后的常量类型一致，或者是课一自动转成可以相互比较的类型，比如输入的是字符，而常量是int2.switch（表达式）中表达式的返回值必须是:(byte,short,int,char,enum[枚举]，String)3.case自居中的值必须是常量，而不能是变量4.default字句是可选的，当没有匹配的case时，执行default5.break语句用在执行完一个case分枝后使得程序跳出switch语句块，如果没有break，程序会顺序执行到switch结尾，除非遇到break；</code></pre><h2 id="switch-和-if-的比较"><a href="#switch-和-if-的比较" class="headerlink" title="switch 和 if 的比较"></a>switch 和 if 的比较</h2><p>1) 如果 判断的具体数值不多，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可以使用，建议使用 swtich 语句。<br>2) 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广</p><h2 id="for-循环控制"><a href="#for-循环控制" class="headerlink" title="for 循环控制(!!!)"></a>for 循环控制(!!!)</h2><pre><code class="java">基本语法for(循环变量初始化；循环条件；循环变量迭代){    循环操作(可以多条语句)；}1. for 关键字，表示循环控制2. for 有四要素: (1)循环变量初始化(2)循环条件(3)循环操作(4)循环变量迭代3. 循环操作 , 这里可以有多条语句，也就是我们要循环执行的代码4. 如果 循环操作(语句) 只有一条语句，可以省略 {}, 建议不要省略 public class 惩罚口诀表 {    public static void main(String[] args) {        for (int i= 1; i &lt; 10; i++) {            for (int j = 1; j &lt;=i; j++) {                System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\t&quot;);            }            System.out.println();        }    }}</code></pre><p>注意事项和细节说明</p><pre><code class="java">1) 循环条件是返回一个布尔值的表达式2) for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。3) 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开。</code></pre><h2 id="while-循环控制"><a href="#while-循环控制" class="headerlink" title="while 循环控制"></a>while 循环控制</h2><pre><code class="java">基本语法while(循环条件){    循环体(语句)；    循环变量迭代；    }</code></pre><p>注意事项和细节说明</p><pre><code class="java">1) 循环条件是返回一个布尔值的表达式2) while 循环是先判断再执行语句</code></pre><h2 id="do-while-循环控制"><a href="#do-while-循环控制" class="headerlink" title="do..while 循环控制"></a>do..while 循环控制</h2><pre><code class="java">基本语法循环变量初始化;do{    循环体( 语句);    循环变量迭代;}while(循环条件);1. do while 是关键字1. 也有循环四要素, 只是位置不一样2. 先执行，再判断，也就是说，一定会至少执行一次3. 最后 有一个 分号 ;</code></pre><p>注意事项和细节说明</p><pre><code class="java">1) 循环条件是返回一个布尔值的表达式2) do..while 循环是先执行，再判断， 因此它至少执行一次</code></pre><h2 id="多重循环控制-难点-重点"><a href="#多重循环控制-难点-重点" class="headerlink" title="多重循环控制(难点! 重点!)"></a>多重循环控制(难点! 重点!)</h2><pre><code class="java"> 介绍1) 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过 3 层, 否则，代码的可读性很差】2) 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。3) 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。</code></pre><p> 多重循环执行步骤分析：</p><pre><code class="java">请分析 下面的多重循环执行步骤, 并写出输出 =&gt; 内存分析法//双层 for MulFor.javafor(int i = 0; i &lt; 2; i++) { //先思考    for( int j = 0; j &lt; 3; j++) {        System.out.println(&quot;i=&quot; + i + j=&quot; + j);    }}</code></pre><h2 id="跳转控制语句-break"><a href="#跳转控制语句-break" class="headerlink" title="跳转控制语句-break"></a>跳转控制语句-break</h2><pre><code class="java">基本语法：{ ……    break;    ……}break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for , while , do-while]中。</code></pre><h2 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句-continue"></a>跳转控制语句-continue</h2><pre><code class="java">基本语法：{ ……    continue;    ……}1) continue 语句用于结束本次循环， 继续执行下一次循环。2) continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的使用的规则一样.</code></pre><h2 id="跳转控制语句-return"><a href="#跳转控制语句-return" class="headerlink" title="跳转控制语句-return"></a>跳转控制语句-return</h2><pre><code class="java">return的常用作用有以下两种:第一种用法是，方法的结束。比如当代码执行到某个地方会出现几种结果，然后其中一种结果就不能执行后续代码，这时候在那里加上一个“return;”就可以终止后面的代码执行。return 使用在方法，表示跳出所在的方法 。第二种是返回方法指定类型的值（这个值总是确定的），也可以是对象public string functionTest(){    return a;}那么这个方法被调用之后就会返回一个值为abc的字符串，</code></pre><h1 id="JavaAPI-文档"><a href="#JavaAPI-文档" class="headerlink" title="JavaAPI 文档"></a>JavaAPI 文档</h1><pre><code class="java">1. API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接     口(java提供的类还有相关的方法)。中文在线文档:   https://www.matools.com2. Java语言提供了大量的基础类，因此Oracle公司也为这些基础类提供了相应的API文档，用于告诉   开发者如何使用这些类，以及这些类里包含的方法。3. Java类的组织形式[java类的组织形式]4.举例说明如何使用ArrayList类有哪些方法.   安包&gt;类-&gt;方法   直接索引. Math</code></pre><p><img src="images\java类的组织形式.png" alt="java类的组织形式"></p><h2 id="ASCII-码介绍-了解"><a href="#ASCII-码介绍-了解" class="headerlink" title="ASCII 码介绍(了解)"></a>ASCII 码介绍(了解)</h2><pre><code>ASCII码:上个世纪60年代，美国制定了一套字符编码(使用个字节)， 对英语字符与二进制位之间的关系，做了统规定，这被称为ASCI码. ASCI码共规走了128个字符的编码，只占甩了一个字节的后面7位，最前面的1位统规定为0。特别提示:一个学书可以表示256个学符，ASCII码只用了128个字符2.看完整的ASCII码表3.缺点:不能表示所有字符。</code></pre><p><img src="images\ASCLL码01.png" alt="ASCLL码" style="zoom:50%;"></p><p><img src="images\ASCLL码02.png" alt="ASCLL码" style="zoom:50%;"></p><h2 id="Unicode-编码介绍-了解"><a href="#Unicode-编码介绍-了解" class="headerlink" title="Unicode 编码介绍(了解)"></a>Unicode 编码介绍(了解)</h2><pre><code>1. Unicode的好处: 一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独   -无二的编码，使用Unicode没有乱码的问题。2. Unicode 的缺点:一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。   3.2的1 6次方是65536,所以最多编码是65536个字符。   4.编码0-127的字符是与ASCII的编码样比如&#39;a&#39; 在ASCII码是0x61，在unicode码是   0x0061,都对应97.因此Unicode码兼容ASCII码.</code></pre><h2 id="UTF-8-编码介绍-了解"><a href="#UTF-8-编码介绍-了解" class="headerlink" title="UTF-8 编码介绍(了解)"></a>UTF-8 编码介绍(了解)</h2><pre><code>1. UTF-8是在互联网上使用最广的一种Unicode的实现方式(改进)2. UTF-8 是一种变长的编码方式。它可以使用1-6个字节表示个符号，根据不   同的符号而变化字节长度。   3.使用大小可变的编码字母占1个字节，汉字占3个字节</code></pre>]]></content>
    
    <summary type="html">
    
      Java基础
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="/2022/03/10/String/"/>
    <id>/2022/03/10/String/</id>
    <published>2022-03-10T02:02:08.797Z</published>
    <updated>2022-03-10T02:03:32.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h3><h4 id="一-常用方法"><a href="#一-常用方法" class="headerlink" title="一.常用方法"></a>一.常用方法</h4><ul><li><pre><code class="java">package com.test03;/** * Settings-Editor-File and Code Templates */public class StringTest {        public static void main(String[] args) {//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写            String str1 = &quot;hello&quot;;            String str2 = &quot;Hello&quot;;            System.out.println(str1.equals(str2));//// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等            String username = &quot;johN&quot;;            if (&quot;john&quot;.equalsIgnoreCase(username)) {                System.out.println(&quot;Success!&quot;);            } else {                System.out.println(&quot;Failure!&quot;);            }// 3.length 获取字符的个数，字符串的长度            System.out.println(&quot;韩顺平&quot;.length());// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1            String s1 = &quot;wer@terwe@g&quot;;            int index = s1.indexOf(&#39;@&#39;);            System.out.println(index);// 3            System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1            s1 = &quot;wer@terwe@g@&quot;;            index = s1.lastIndexOf(&#39;@&#39;);            System.out.println(index);//11            System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4// 6.substring 截取指定范围的子串            String name = &quot;hello,张三&quot;;//下面 name.substring(6) 从索引 6 开始截取后面所有的内容            System.out.println(name.substring(6));//截取后面的字符//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置            System.out.println(name.substring(2,5));//llo        }}</code></pre></li></ul><pre><code class="java">package com.test03;/** * Settings-Editor-File and Code Templates */public class StringTest02 {        public static void main(String[] args) {// 1.toUpperCase 转换成大写            String s = &quot;heLLo&quot;;            System.out.println(s.toUpperCase());//HELLO// 2.toLowerCase            System.out.println(s.toLowerCase());//hello// 3.concat 拼接字符串            String s1 = &quot;宝玉&quot;;            s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;);            System.out.println(s1);//宝玉林黛玉薛宝钗 together// 4.replace 替换字符串中的字符            s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;;//在 s1 中，将 所有的 林黛玉 替换成薛宝钗//  s1.replace() 方法执行后，返回的结果才是替换过的.// 注意对 s1 没有任何影响            String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;);            System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉            System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等            String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \            String[] split = poem.split(&quot;,&quot;);            poem = &quot;E:\\aaa\\bbb&quot;;            split = poem.split(&quot;\\\\&quot;);            System.out.println(&quot;==分割后内容===&quot;);            for (int i = 0; i &lt; split.length; i++) {                System.out.println(split[i]);            }// 6.toCharArray 转换成字符数组                    s = &quot;happy&quot;;            char[] chs = s.toCharArray();            for (int i = 0; i &lt; chs.length; i++) {                System.out.println(chs[i]);            }// 7.compareTo 比较两个字符串的大小，如果前者大，// 则返回正数，后者大，则返回负数，如果相等，返回 0// (1) 如果长度相同，并且每个字符也相同，就返回 0// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小// 就返回 if (c1 != c2) {// return c1 - c2;// }// (3) 如果前面的部分都相同，就返回 str1.len - str2.len            String a = &quot;jcck&quot;;// len = 3            String b = &quot;jack&quot;;// len = 4            System.out.println(a.compareTo(b)); // 返回值是 &#39;c&#39; - &#39;a&#39; = 2 的值// 8.format 格式字符串            /* 占位符有:             * %s 字符串 %c 字符 %d 整型 %.2f 浮点型             *             */            String name = &quot;john&quot;;            int age = 10;            double score = 56.857;            char gender = &#39;男&#39;;//将所有的信息都拼接在一个字符串.            String info =                    &quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！ &quot;;            System.out.println(info);//1. %s , %d , %.2f %c 称为占位符//2. 这些占位符由后面变量来替换//3. %s 表示后面由 字符串来替换//4. %d 是整数来替换//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理//6. %c 使用 char 类型来替换            String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;;            String info2 = String.format(formatStr, name, age, score, gender);            System.out.println(&quot;info2=&quot; + info2);        }}</code></pre><h3 id="StringBuffer-类："><a href="#StringBuffer-类：" class="headerlink" title="StringBuffer 类："></a>StringBuffer 类：</h3><pre><code class="java">public class StringBuffer01 {public static void main(String[] args) {//1. StringBuffer 的直接父类 是 AbstractStringBuilder//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final// 该 value 数组存放 字符串内容，引出存放在堆中的//4. StringBuffer 是一个 final 类，不能被继承//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 StringStringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);}}</code></pre><h4 id="String-VS-StringBuffer"><a href="#String-VS-StringBuffer" class="headerlink" title="String VS StringBuffer"></a>String VS StringBuffer</h4><p>1) String保存的是字符串常量，里面的值不能更改，每次String类的更新实际<br>上就是更改地址， 效率较低//private final char value[];<br>2) StringBuffer保存的是字符串变量，里面的值可以更改，每次<br>StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高<br>//char[] value; /这个放在堆</p><h4 id="String-和-StringBuffer-相互转换"><a href="#String-和-StringBuffer-相互转换" class="headerlink" title="String 和 StringBuffer 相互转换"></a>String 和 StringBuffer 相互转换</h4><ul><li><p><code>`</code>java<br>public class StringAndStringBuffer {<br>public static void main(String[] args) {<br>//看 String——&gt;StringBuffer</p><p>String str = “hello tom”;<br>//方式 1 使用构造器<br>//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响<br>StringBuffer stringBuffer = new StringBuffer(str);<br>//方式 2 使用的是 append 方法<br>StringBuffer stringBuffer1 = new StringBuffer();<br>stringBuffer1 = stringBuffer1.append(str);<br>//看看 StringBuffer -&gt;String<br>StringBuffer stringBuffer3 = new StringBuffer(“韩顺平教育”);<br>//方式 1 使用 StringBuffer 提供的 toString 方法<br>String s = stringBuffer3.toString();<br>//方式 2: 使用构造器来搞定<br>String s1 = new String(stringBuffer3);<br>}<br>}<br>13.5.4 StringBuffer 类常见方法<br>package com.hspedu.stringbuffer_;</p></li></ul><pre><code>public class StringBufferMethod {public static void main(String[] args) {StringBuffer s = new StringBuffer(&quot;hello&quot;);//增s.append(&#39;,&#39;);// &quot;hello,&quot;s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot;System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot;//删/*</code></pre><ul><li>删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</li><li><p>解读: 删除 11~14 的字符 [11, 14)<br>*/<br>s.delete(11, 14);<br>System.out.println(s);//“hello,张三丰赵敏 true10.5”<br>//改<br>//，使用 周芷若 替换 索引 9-11 的字符 [9,11)<br>s.replace(9, 11, “周芷若”);<br>System.out.println(s);//“hello,张三丰周芷若 true10.5”<br>//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1<br>int indexOf = s.indexOf(“张三丰”);<br>System.out.println(indexOf);//6<br>//插</p><p>//，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移<br>s.insert(9, “赵敏”);<br>System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”<br>//长度<br>System.out.println(s.length());//22<br>System.out.println(s);<br>}<br>}</p><p><code>`</code></p><h4 id="StringBuffer-类常见方法"><a href="#StringBuffer-类常见方法" class="headerlink" title="StringBuffer 类常见方法"></a>StringBuffer 类常见方法</h4><p><code>`</code>java</p></li><li><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p>public class StringBufferMethod {<br>public static void main(String[] args) {<br>StringBuffer s = new StringBuffer(“hello”);<br>//增<br>s.append(‘,’);// “hello,”<br>s.append(“张三丰”);//“hello,张三丰”<br>s.append(“赵敏”).append(100).append(true).append(10.5);//“hello,张三丰赵敏 100true10.5”<br>System.out.println(s);//“hello,张三丰赵敏 100true10.5”<br>//删<br>/*</p></li><li><p>删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</p></li><li><p>解读: 删除 11~14 的字符 [11, 14)<br>*/<br>s.delete(11, 14);<br>System.out.println(s);//“hello,张三丰赵敏 true10.5”<br>//改<br>//，使用 周芷若 替换 索引 9-11 的字符 [9,11)<br>s.replace(9, 11, “周芷若”);<br>System.out.println(s);//“hello,张三丰周芷若 true10.5”<br>//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1<br>int indexOf = s.indexOf(“张三丰”);<br>System.out.println(indexOf);//6<br>//插</p><p>//，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移<br>s.insert(9, “赵敏”);<br>System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”<br>//长度<br>System.out.println(s.length());//22<br>System.out.println(s);<br>}<br>}<br><code>`</code></p></li></ul><h4 id="StringBuffer-类测试题-1-StringBufferExercise01-java"><a href="#StringBuffer-类测试题-1-StringBufferExercise01-java" class="headerlink" title="StringBuffer 类测试题 1 StringBufferExercise01.java"></a>StringBuffer 类测试题 1 StringBufferExercise01.java</h4><pre><code class="java">public class StringBufferExercise01 {public static void main(String[] args) {String str = null;// okStringBuffer sb = new StringBuffer(); //oksb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNullSystem.out.println(sb.length());//4System.out.println(sb);//null韩顺平学 循序渐进学 Java 零基础第 561页//下面的构造器，会抛出 NullpointerExceptionStringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);System.out.println(sb1);}}</code></pre><pre><code class="java">public class StringBufferExercise02 {public static void main(String[] args) {/*输入商品名称和商品价格，要求打印效果示例, 使用前面学习的方法完成：商品名 商品价格手机 123,564.59 //比如 价格 3,456,789.88要求：价格的小数点前面每三位用逗号隔开, 在输出。思路分析1. 定义一个 Scanner 对象，接收用户输入的 价格(String)2. 希望使用到 StringBuffer 的 insert ，需要将 String 转成 StringBuffer3. 然后使用相关方法进行字符串的处理   代码实现   */   //new Scanner(System.in)   String price = &quot;8123564.59&quot;;   StringBuffer sb = new StringBuffer(price);   //先完成一个最简单的实现 123,564.59   //找到小数点的索引，然后在该位置的前 3 位，插入,即可   // int i = sb.lastIndexOf(&quot;.&quot;);   // sb = sb.insert(i - 3, &quot;,&quot;);   //上面的两步需要做一个循环处理,才是正确的   for (int i = sb.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0; i -= 3) {   sb = sb.insert(i, &quot;,&quot;);   }   System.out.println(sb);//8,123,564.59   }   }</code></pre><p>StringBuilder01 java<br>1)一个可变的字符序列。此类提供一个与StringBuffer兼容的API,但不保证同<br>步(StringBuilder不是线程安全)。该类被设计用作StringBuffer的一个简易<br>替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类<br>因为在大多数实现中，它比StringBuffer要快[后面测]。<br>2)在StringBuilder上的主要操作是append和insert方法，可重载这些方法，<br>以接受任意类型的数据。</p><pre><code class="java">public class StringBuffer01 {public static void main(String[] args) {//1. StringBuffer 的直接父类 是 AbstractStringBuilder//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final// 该 value 数组存放 字符串内容，引出存放在堆中的//4. StringBuffer 是一个 final 类，不能被继承//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 StringStringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);}}</code></pre><pre><code class="java">public class StringBuilder01 {public static void main(String[] args) {//1. StringBuilder 继承 AbstractStringBuilder 类//2. 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件)//3. StringBuilder 是 final 类, 不能被继承//4. StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value;// 因此，字符序列是堆中//5. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用// StringBuilderStringBuilder stringBuilder = new StringBuilder();}}</code></pre><p> String、StringBuffer 和 StringBuilder 的比较</p><p>1) StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法<br>也一样<br>2) String: 不可变字符序列，效率低,但是复用率高。<br>3) StringBuffer: 可变字符序列、效率较高(增删)、线程安全，看源码<br>4) StringBuilder: 可变字符序列、效率最高、线程不安全<br>5) String使用注意说明:<br>string s= “a”; //创建了一个字符串<br>s += “b”; //实际上原来的” a”字符串对象已经丢弃了，现在又产生了一个字符I<br>串s+”b” (也就是”ab”)。 如果多次执行这些改变串内容的操作，会导致大量副<br>本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大<br>影响程序的性能=&gt;结论:如果我们对String做大量修改，不要使用String</p><h4 id="String、StringBuffer-和-StringBuilder-的选择"><a href="#String、StringBuffer-和-StringBuilder-的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder 的选择"></a>String、StringBuffer 和 StringBuilder 的选择</h4><p>使用的原则， 结论:<br>1.如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder<br>2.如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder<br>3.如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer<br>4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等<br>StringBuilder的方法使用和StringBuffer一样</p><h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><h4 id="Math-类常见方法"><a href="#Math-类常见方法" class="headerlink" title="Math 类常见方法"></a>Math 类常见方法</h4><pre><code class="java">public class MathMethod {public static void main(String[] args) {//看看 Math 常用的方法(静态方法)//1.abs 绝对值int abs = Math.abs(-9);System.out.println(abs);//9//2.pow 求幂double pow = Math.pow(2, 4);//2 的 4 次方System.out.println(pow);//16//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);double ceil = Math.ceil(3.9);System.out.println(ceil);//4.0//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)double floor = Math.floor(4.001);System.out.println(floor);//4.0//5.round 四舍五入 Math.floor(该参数+0.5)long round = Math.round(5.51);System.out.println(round);//6//6.sqrt 求开方double sqrt = Math.sqrt(9.0);System.out.println(sqrt);//3.0//7.random 求随机数// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7// 即返回一个数 x 2 &lt;= x &lt;= 7//  Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )for(int i = 0; i &lt; 100; i++) {System.out.println((int)(2 + Math.random() * (7 - 2 + 1)));}//max , min 返回最大值和最小值int min = Math.min(1, 9);int max = Math.max(45, 90);System.out.println(&quot;min=&quot; + min);System.out.println(&quot;max=&quot; + max);}}</code></pre><h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><h4 id="Arrays-类常见方法应用"><a href="#Arrays-类常见方法应用" class="headerlink" title="Arrays 类常见方法应用"></a>Arrays 类常见方法应用</h4><pre><code class="java">public class ArraysMethod01 {public static void main(String[] args) {Integer[] integers = {1, 20, 90};//遍历数组// for(int i = 0; i &lt; integers.length; i++) {// System.out.println(integers[i]);// }//直接使用 Arrays.toString 方法，显示数组// System.out.println(Arrays.toString(integers));////演示 sort 方法的使用Integer arr[] = {1, -1, 7, 0, 89};//进行排序//1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序//2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr//3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序//4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr// (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法//5. 先演示效果，再解释//6. 这里体现了接口编程的方式 , 看看源码，就明白// 源码分析//(1)Arrays.sort(arr, new Comparator()//(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start,// Comparator&lt;? super T&gt; c)()//(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的// 匿名内部类的 compare ()// while (left &lt; right) {// int mid = (left + right) &gt;&gt;&gt; 1;// if (c.compare(pivot, a[mid]) &lt; 0)// right = mid;// else// left = mid + 1;// }//(4) new Comparator() {// @Override// public int compare(Object o1, Object o2) {// Integer i1 = (Integer) o1;// Integer i2 = (Integer) o2;// return i2 - i1;// }// }//(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0// 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用// 将来的底层框架和源码的使用方式，会非常常见//Arrays.sort(arr); // 默认排序方法//定制排序Arrays.sort(arr, new Comparator() {@Overridepublic int compare(Object o1, Object o2) {Integer i1 = (Integer) o1;Integer i2 = (Integer) o2;return i2 - i1;}});System.out.println(&quot;===排序后===&quot;);System.out.println(Arrays.toString(arr));//}}</code></pre><pre><code class="java">public class ArraysSortCustom {public static void main(String[] args) {int[] arr = {1, -1, 8, 0, 20};//bubble01(arr);bubble02(arr, new Comparator() {@Overridepublic int compare(Object o1, Object o2) {int i1 = (Integer) o1;int i2 = (Integer) o2;return i2 - i1;// return i2 - i1;}});System.out.println(&quot;==定制排序后的情况==&quot;);System.out.println(Arrays.toString(arr));}//使用冒泡完成排序public static void bubble01(int[] arr) {int temp = 0;for (int i = 0; i &lt; arr.length - 1; i++) {for (int j = 0; j &lt; arr.length - 1 - i; j++) {//从小到大if (arr[j] &gt; arr[j + 1]) {temp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = temp;}}}}</code></pre><pre><code class="java">//结合冒泡 + 定制public static void bubble02(int[] arr, Comparator c) {int temp = 0;for (int i = 0; i &lt; arr.length - 1; i++) {for (int j = 0; j &lt; arr.length - 1 - i; j++) {//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定if (c.compare(arr[j], arr[j + 1]) &gt; 0) {temp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = temp;}}}}}</code></pre><ul><li><code>`</code>java<br>package com.hspedu.arrays_;<br>import java.util.Arrays;<br>import java.util.List;</li></ul><pre><code>public class ArraysMethod02 {public static void main(String[] args) {Integer[] arr = {1, 2, 90, 123, 567};// binarySearch 通过二分搜索法进行查找，要求必须排好//1. 使用 binarySearch 二叉查找//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch//3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found.int index =Arrays.binarySearch(arr, 567);System.out.println(&quot;index=&quot; + index);//copyOf 数组元素的复制//1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null//3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException//4. 该方法的底层使用的是 System.arraycopy()Integer[] newArr =Arrays.copyOf(arr, arr.length);System.out.println(&quot;==拷贝执行完毕后==&quot;);System.out.println(Arrays.toString(newArr));//ill 数组元素的填充Integer[] num = new Integer[]{9,3,2};//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素Arrays.fill(num, 99);System.out.println(&quot;==num 数组填充后==&quot;);System.out.println(Arrays.toString(num));//equals 比较两个数组元素内容是否完全一致Integer[] arr2 = {1, 2, 90, 123};//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;//2. 如果不是完全一样，就返回 falseboolean equals =Arrays.equals(arr, arr2);System.out.println(&quot;equals=&quot; + equals);//asList 将一组值，转换成 list//1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合//2. 返回的 asList 编译类型 List(接口)//3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的// 静态内部类 private static class ArrayList&lt;E&gt; extendsAbstractList&lt;E&gt;// implements RandomAccess, java.io.SerializableList asList =Arrays.asList(2,3,4,5,6,1);System.out.println(&quot;asList=&quot; + asList);System.out.println(&quot;asList 的运行类型&quot; + asList.getClass());}}</code></pre><pre><code>  ### date日期类  Date:精确到毫秒，代表特定的瞬间2) SimpleDateFormat:格式和解析日期的类SimpleDateFormat格式化和解析日期的具体类。它允许进行格式化(日期-&gt;文本)解析(文本-&gt;日期)和规范化.| 3) 应用实例Date java2) </code></pre><p>//1. Calendar 是一个抽象类， 并且构造器是 private<br>//2. 可以通过 getInstance() 来获取实例<br>//3. 提供大量的方法和字段提供给程序员</p><p>//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)<br>//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY<br>Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由<br>System.out.println(“c=” + c);<br>//2.获取日历对象的某个日历字段<br>System.out.println(“年：” + c.get(Calendar.YEAR));<br>// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号<br>System.out.println(“月：” + (c.get(Calendar.MONTH) + 1));<br>System.out.println(“日：” + c.get(Calendar.DAY_OF_MONTH));<br>System.out.println(“小时：” + c.get(Calendar.HOUR));<br>System.out.println(“分钟：” + c.get(Calendar.MINUTE));<br>System.out.println(“秒：” + c.get(Calendar.SECOND));<br>//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示<br>System.out.println(c.get(Calendar.YEAR) + “-“ + (c.get(Calendar.MONTH) + 1) + “-“ +<br>c.get(Calendar.DAY_OF_MONTH) +<br>“ “ + c.get(Calendar.HOUR_OF_DAY) + “:” + c.get(Calendar.MINUTE) + “:” + c.get(Calendar.SECOND) );<br>}<br>}</p><pre><code>#### 第三代日期类</code></pre><p>//1. 使用 now() 返回表示当前日期时间的 对象<br>LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()<br>System.out.println(ldt);<br>//2. 使用 DateTimeFormatter 对象来进行格式化<br>// 创建 DateTimeFormatter 对象<br>DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);<br>String format = dateTimeFormatter.format(ldt);<br>System.out.println(“格式化的日期=” + format);<br>System.out.println(“年=” + ldt.getYear());<br>System.out.println(“月=” + ldt.getMonth());<br>System.out.println(“月=” + ldt.getMonthValue());<br>System.out.println(“日=” + ldt.getDayOfMonth());<br>System.out.println(“时=” + ldt.getHour());<br>System.out.println(“分=” + ldt.getMinute());<br>System.out.println(“秒=” + ldt.getSecond());<br>LocalDate now = LocalDate.now(); //可以获取年月日</p><p>LocalTime now2 = LocalTime.now();//获取到时分秒<br>//提供 plus 和 minus 方法可以对当前时间进行加或者减<br>//看看 890 天后，是什么时候 把 年月日-时分秒<br>LocalDateTime localDateTime = ldt.plusDays(890);<br>System.out.println(“890 天后=” + dateTimeFormatter.format(localDateTime));<br>//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出<br>LocalDateTime localDateTime2 = ldt.minusMinutes(3456);<br>System.out.println(“3456 分钟前 日期=” + dateTimeFormatter.format(localDateTime2));<br>}<br>}</p><pre><code>#### 时间戳</code></pre><p>//1.通过 静态方法 now() 获取表示当前时间戳的对象<br>Instant now = Instant.now();<br>System.out.println(now);<br>//2. 通过 from 可以把 Instant 转成 Date<br>Date date = Date.from(now);</p><p>//3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象<br>Instant instant = date.toInstant();<br>}<br>}</p><pre><code>####  数组</code></pre><p>1)长度开始时必须指定，而且一旦指定，不能正改<br>2)保存的必须为同一类型的元素<br>3)使用数组进行增加/删除元素的示意代码-比较麻烦</p><pre><code>#### 集合</code></pre><p>1)可以动态保存任意多个对象，使用比较方便!<br>2)提供了一系列方便的操作对象的方法: add. remove. set, get等<br>3)使用集合添加，删除新元素的示意代码简洁了</p><pre><code> 集合的框架体系Java 的集合类很多，主要分为两大类，如图 ：[背下来]Collection_.java//1. 集合主要是两组(单列集合 , 双列集合)//2. Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合//3. Map 接口的实现子类 是双列集合，存放的 K-V![image-20220216112130181](C:\Users\张\AppData\Roaming\Typora\typora-user-images\image-20220216112130181.png)![image-20220216112134559](C:\Users\张\AppData\Roaming\Typora\typora-user-images\image-20220216112134559.png)##### Collection 接口和常用方法1) collection实现子类可以存放多个元素，每个元素可以是Object2)有些Collection的实现类， 可以存放重复的元素，有些不可以3)有些Collection的实现类， 有些是有序的(List),有些不是有序(Set)4) Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的collection 接口常用方法,以实现子类 ArrayListList list = newArrayList();// add:添加单个元素remove:删除指定元素contains:查找元素是否存在size:获取元素个数isEmpty:判断是否为空clear:清空addAll:添加多个元素containsAll:查找多个元素是否都存在removeAll：删除多个元素##### Collection 接口遍历元素方式 1-使用 Iterator(迭代器)1) lterator对象称为迭代器，主要用于遍历Collection集合中的元案。2)所有实现了Collection接口的集合类都有一个iterator(方法， 用以返回一个实现了 lterator接口的对象，即可以返回一个迭代器。3) Iterator的结构.[看-张图]4) Iterator仅用于遍历集合，Iterator 本身并不存放对象。</code></pre><p>迭代器的执行原理<br>Iterator iterator = oll.iterator0; //得到<br>个集合的迭代器<br>//hasNext():判断是否还有下一个元素<br>while(iterator.hasNextO{<br>//next作用:1.下移2.将下移以后集合位置<br>.上的元素返回<br>System. out.println(iterator.next0);</p><p>快速生成 while =&gt; itit<br>//显示所有的快捷键的的快捷键 ctrl + j</p><pre><code>#####  Collection 接口遍历对象方式 2-for 循环增强增强for循环， 可以代替iterator迭代器，特点:增强for就是简化版的iterat本质样。只能用于遍历集合或数组。快捷建大寫   I&gt;</code></pre><blockquote><p>基本语法<br>for(元素类型元素名:集合名或数组名) {<br>访问元素<br>案例演示(遍历Book,并使用Debug源码来证明)<br>CollectionForjava<br>for (Object object: col) {<br>System. outprintln(object);<br><code>`</code></p><h3 id="List-接口和常用方法"><a href="#List-接口和常用方法" class="headerlink" title="List 接口和常用方法"></a>List 接口和常用方法</h3></blockquote><pre><code>/1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复 [案例]List list = newArrayList();list.add(&quot;jack&quot;);list.add(&quot;tom&quot;);list.add(&quot;mary&quot;);list.add(&quot;hsp&quot;);/2. List 集合中的每个元素都有其对应的顺序索引，即支持索引// 索引是从 0 开始的System.out.println(list.get(3));</code></pre><pre><code>public static void main(String[] args) {List list = newArrayList();list.add(&quot;张三丰&quot;);list.add(&quot;贾宝玉&quot;);// void add(int index, Object ele):在 index 位置插入 ele 元素//在 index = 1 的位置插入一个对象list.add(1, &quot;啊啊啊&quot;);System.out.println(&quot;list=&quot; + list);// boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来List list2 = newArrayList();list2.add(&quot;jack&quot;);list2.add(&quot;tom&quot;);list.addAll(1, list2);System.out.println(&quot;list=&quot; + list);// Object get(int index):获取指定 index 位置的元素// int indexOf(Object obj):返回 obj 在集合中首次出现的位置System.out.println(list.indexOf(&quot;tom&quot;));//2// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置list.add(&quot;啊啊啊&quot;);System.out.println(&quot;list=&quot; + list);System.out.println(list.lastIndexOf(&quot;啊啊啊&quot;));// Object remove(int index):移除指定 index 位置的元素，并返回此元素list.remove(0);System.out.println(&quot;list=&quot; + list);// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换.list.set(1, &quot;玛丽&quot;);System.out.println(&quot;list=&quot; + list);// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndexList returnlist = list.subList(0, 2);System.out.println(&quot;returnlist=&quot; + returnlist);}}</code></pre>]]></content>
    
    <summary type="html">
    
      String使用教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>练习</title>
    <link href="/2022/03/10/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>/2022/03/10/基础语法/</id>
    <published>2022-03-10T02:02:08.773Z</published>
    <updated>2022-03-10T02:07:20.279Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法递归调用-非常非常重要，比较难"><a href="#方法递归调用-非常非常重要，比较难" class="headerlink" title="方法递归调用(非常非常重要，比较难)"></a>方法递归调用(非常非常重要，比较难)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变<br>得简洁</p><h4 id="递归能解决什么问题"><a href="#递归能解决什么问题" class="headerlink" title="递归能解决什么问题?"></a>递归能解决什么问题?</h4><p>列举两个小案例,来帮助大家理解递归调用机制</p><ol><li><p>打印问题</p></li><li><p>阶乘问题<br>代码</p><pre><code class="java">public class Recursion01 {//编写一个 main 方法public static void main(String[] args) {T t1 = new T();t1.test(4);//输出什么？ n=2 n=3 n=4int res = t1.factorial(5);System.out.println(&quot;5 的阶乘 res =&quot; + res);}}class T {//分析public void test(int n) {if (n &gt; 2) {test(n - 1);}System.out.println(&quot;n=&quot; + n);}</code></pre><p>韩顺平学 循序渐进学 Java 零基础<br>第 220页</p><pre><code class="java">//factorial 阶乘public int factorial(int n) {if (n == 1) {return 1;} else {return factorial(n - 1) * n;}}}</code></pre></li></ol><p>代码</p><pre><code class="java">public class RecursionExercise01 {//编写一个 main 方法public static void main(String[] args) {T t1 = new T();// int n = 7;// int res = t1.fibonacci(n);// if(res != -1) {// System.out.println(&quot;当 n=&quot;+ n +&quot; 对应的斐波那契数=&quot; + res);// }////桃子问题int day = 0;int peachNum = t1.peach(day);if(peachNum != -1) {System.out.println(&quot;第 &quot; + day + &quot;天有&quot; + peachNum + &quot;个桃子&quot;);}    }}class T {/*请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的值是多思路分析1. 当 n = 1 斐波那契数 是 12. 当 n = 2 斐波那契数 是 13. 当 n &gt;= 3 斐波那契数 是前两个数的和4. 这里就是一个递归的思路*/public int fibonacci(int n) {if( n &gt;= 1) {if( n == 1 || n == 2) {return 1;} else {return fibonacci(n-1) + fibonacci(n-2);}} else {System.out.println(&quot;要求输入的 n&gt;=1 的整数&quot;);return -1;}}</code></pre><p>猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！<br>以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时，<br>想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子？<br>思路分析 逆推</p><ol><li><p>day = 10 时 有 1 个桃子</p></li><li><p>day = 9 时 有 (day10 + 1) * 2 = 4</p></li><li><p>day = 8 时 有 (day9 + 1) * 2 = 10</p></li><li><p>规律就是 前一天的桃子 = (后一天的桃子 + 1) *2//就是我们的能力</p></li><li><p>递归<br>*/</p><pre><code class="java">public int peach(int day) {if(day == 10) {//第 10 天，只有 1 个桃return 1;} else if ( day &gt;= 1 &amp;&amp; day &lt;=9 ) {return (peach(day + 1) + 1) * 2;//规则，自己要想} else {System.out.println(&quot;day 在 1-10&quot;);return -1;}}}</code></pre></li></ol><h2 id="数字迷宫找出路"><a href="#数字迷宫找出路" class="headerlink" title="数字迷宫找出路"></a>数字迷宫找出路</h2><pre><code class="java">package com;public class MIGong {    public static void main(String[] args) {//        创建明迷宫//        0表示路径 1表示障碍        int[][] map=new int [18][17];        for (int i = 0; i &lt; 17; i++) {            map[0][i]=1;            map[17][i]=1;        }        for (int i = 0; i &lt; 18; i++) {            map[i][0]=1;            map[i][16]=1;        }        map[3][4]=1;        map[3][5]=1;        map[3][6]=1;        map[3][7]=1;        map[4][4]=1;        map[5][4]=1;        map[2][1]=1;        map[2][2]=1;        map[3][2]=1;        map[5][3]=1;        map[16][15]=3;        Te te = new Te();        te.findWay(map,1,1);        System.out.println(&quot;======招錄情況=======&quot;);//输出地图        System.out.println(&quot;======地图======&quot;);        for (int i = 0; i &lt; map.length; i++) {            for (int j = 0; j &lt; map[i].length; j++) {                System.out.print(map[i][j]+&quot; &quot;);            }            System.out.println();        }    }}class Te {    public boolean findWay(int[][] map,int i,int j){//        int a[][]=map[1][1];        if (map[15][14]==2){//説明找到路            return true;        }else {            if (map[i][j]==0){                map[i][j]=2;                if (findWay(map,i+1,j)){                    return true;                }else if (findWay(map,i,j+1)){                    return true;                }else if (findWay(map, i-1, j)){                    return true;                }else if (findWay(map, i, j-1)){                    return true;                }else {                    map[i][j]=3;                    return false;                }            }            return false;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      基础算法
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Nacos安装</title>
    <link href="/2022/03/10/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <id>/2022/03/10/Nacos安装指南/</id>
    <published>2022-03-10T01:29:35.424Z</published>
    <updated>2022-03-10T01:58:43.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>如图：<br><img src="source/_posts/assets/image-20210402161102887.png" alt><br><img src="source/_posts/assets/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="assets/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="assets/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="assets/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="assets/image-20210402162251093.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="assets/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><pre><code>startup.cmd -m standalone</code></pre></li></ul><p>执行后的效果如图：</p><p><img src="assets/image-20210402162526774.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos即可：" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="assets/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="assets/image-20210402162709515.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="assets/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><pre><code class="sh">tar -xvf jdk-8u144-linux-x64.tar.gz</code></pre><p>然后重命名为java</p><p>配置环境变量：</p><pre><code class="sh">export JAVA_HOME=/usr/local/javaexport PATH=$PATH:$JAVA_HOME/bin</code></pre><p>设置环境变量：</p><pre><code class="sh">source /etc/profile</code></pre><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="assets/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="assets/image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="assets/image-20210402163715580.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><pre><code class="sh">tar -xvf nacos-server-1.4.1.tar.gz</code></pre><p>然后删除安装包：</p><pre><code class="sh">rm -rf nacos-server-1.4.1.tar.gz</code></pre><p>目录中最终样式：</p><p><img src="assets/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="assets/image-20210402164414827.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><pre><code class="sh">sh startup.sh -m standalone</code></pre><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>客户端：</p><pre><code class="xml">&lt;!-- nacos客户端依赖包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      Nacos安装教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker介绍及使用</title>
    <link href="/2022/03/10/1.1.%E4%BB%80%E4%B9%88%E6%98%AFDocker/"/>
    <id>/2022/03/10/1.1.什么是Docker/</id>
    <published>2022-03-10T01:27:18.470Z</published>
    <updated>2022-03-10T01:28:24.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p>对比来看：</p><p><img src="E:\baiduyunpan\springcloud\学习资料\day03-Docker\讲义\assets\image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。</p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令</p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a>:</p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p>3）通过命令：docker images 查看拉取到的镜像</p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><pre><code class="sh">docker save --help</code></pre><p>命令格式：</p><pre><code class="shell">docker save -o [保存的目标文件名称] [镜像名称]</code></pre><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><pre><code class="sh">docker save -o nginx.tar nginx:latest</code></pre><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><pre><code class="sh">docker rmi nginx:latest</code></pre><p>然后运行命令，加载本地文件：</p><pre><code class="sh">docker load -i nginx.tar</code></pre>]]></content>
    
    <summary type="html">
    
      docker使用教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安装Docker</title>
    <link href="/2022/03/09/%E5%AE%89%E8%A3%85Docker/"/>
    <id>/2022/03/09/安装Docker/</id>
    <published>2022-03-09T12:58:01.864Z</published>
    <updated>2022-03-10T01:28:20.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><pre><code>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine \                  docker-ce</code></pre><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><pre><code class="sh">sudo yum install -y yum-utils \           device-mapper-persistent-data \           lvm2 --skip-broken</code></pre><p>然后更新本地镜像源：</p><pre><code class="shell"># 设置docker镜像源yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposed -i &#39;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repoyum makecache fast</code></pre><p>然后输入命令：</p><pre><code class="shell">yum install -y docker-ce</code></pre><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><pre><code class="sh"># 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld</code></pre><p>通过命令启动docker：</p><pre><code class="sh">systemctl start docker  # 启动docker服务systemctl stop docker  # 停止docker服务systemctl restart docker  # 重启docker服务</code></pre><p>然后输入命令，可以查看docker版本：</p><pre><code>docker -v</code></pre><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><pre><code class="shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &quot;registry-mirrors&quot;:[&quot;https://n0dwemtq.mirror.aliyuncs.com&quot;] }EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><pre><code class="sh"># 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="assets/image-20210417133020614.png" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><pre><code class="sh"># 修改权限chmod +x /usr/local/bin/docker-compose</code></pre><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><pre><code class="sh"># 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><p>如果这里出现错误，需要修改自己的hosts文件：</p><pre><code class="sh">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</code></pre><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry" target="_blank" rel="noopener">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><pre><code class="sh">docker run -d \    --restart=always \    --name registry    \    -p 5000:5000 \    -v registry-data:/var/lib/registry \    registry</code></pre><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://YourIp:5000/v2/_catalog" target="_blank" rel="noopener">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><pre><code class="yaml">version: &#39;3.0&#39;services:  registry:    image: registry    volumes:      - ./registry-data:/var/lib/registry  ui:    image: joxit/docker-registry-ui:static    ports:      - 8080:80    environment:      - REGISTRY_TITLE=传智教育私有仓库      - REGISTRY_URL=http://registry:5000    depends_on:      - registry</code></pre><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><pre><code class="sh"># 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker</code></pre>]]></content>
    
    <summary type="html">
    
      docker安装教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="/2021/12/12/Test/"/>
    <id>/2021/12/12/Test/</id>
    <published>2021-12-12T14:16:01.000Z</published>
    <updated>2022-03-10T02:03:20.897Z</updated>
    
    <content type="html"><![CDATA[<!-- 添加图片 --><!-- ![](https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg) -->   <!-- 添加链接 --><p><a href="https://github.com/" target="_blank" rel="noopener">前往github</a></p><!-- 添加标题 --><!-- ## 交流群 --><!-- 添加 --><!--     ## 主题特性<!-- 添加选项 --> <!-- - 首页大屏视频 - 首页随机封面 - 图片懒加载 - valine评论 - fancy-box相册 - pjax支持，音乐不间断 - aplayer音乐播放器 --> <p>yml</p><pre><code class="yml"></code></pre><p>java</p><pre><code class="java">public static void mian(String[] args){}</code></pre>]]></content>
    
    <summary type="html">
    
      主题使用教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch</title>
    <link href="/2021/12/12/%E5%AE%89%E8%A3%85elasticsearch/"/>
    <id>/2021/12/12/安装elasticsearch/</id>
    <published>2021-12-12T14:16:01.000Z</published>
    <updated>2022-03-10T02:00:28.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h1><h1 id="1-部署单点es"><a href="#1-部署单点es" class="headerlink" title="1.部署单点es"></a>1.部署单点es</h1><h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><pre><code class="sh">docker network create es-net</code></pre><h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>大家将其上传到虚拟机中，然后运行命令加载即可：</p><pre><code class="sh"># 导入数据docker load -i es.tar</code></pre><p>同理还有<code>kibana</code>的tar包也需要这样做。</p><h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p><pre><code class="sh">docker run -d \    --name es \    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \    -e &quot;discovery.type=single-node&quot; \    -v es-data:/usr/share/elasticsearch/data \    -v es-plugins:/usr/share/elasticsearch/plugins \    --privileged \    --network es-net \    -p 9200:9200 \    -p 9300:9300 \elasticsearch:7.12.1</code></pre><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://192.168.150.101:9200" target="_blank" rel="noopener">http://192.168.150.101:9200</a> 即可看到elasticsearch的响应结果</p><h1 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p><h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana</p><pre><code class="sh">docker run -d \--name kibana \-e ELASTICSEARCH_HOSTS=http://es:9200 \--network=es-net \-p 5601:5601  \kibana:7.12.1</code></pre><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><pre><code class="sh">docker logs -f kibana</code></pre><p>查看运行日志，查看是否成功。</p><p>在浏览器输入地址访问：<a href="http://192.168.150.101:5601，即可看到结果" target="_blank" rel="noopener">http://192.168.150.101:5601，即可看到结果</a></p><h2 id="2-2-DevTools"><a href="#2-2-DevTools" class="headerlink" title="2.2.DevTools"></a>2.2.DevTools</h2><p>kibana中提供了一个DevTools界面：</p><p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p><h1 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h1><p>(<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a>)</p><p>(<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a>)</p><h2 id="3-1-在线安装ik插件（较慢）"><a href="#3-1-在线安装ik插件（较慢）" class="headerlink" title="3.1.在线安装ik插件（较慢）"></a>3.1.在线安装ik插件（较慢）</h2><pre><code class="shell"># 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch</code></pre><h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><pre><code class="sh">docker volume inspect es-plugins</code></pre><p>显示结果：</p><pre><code class="json">[    {        &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;,        &quot;Name&quot;: &quot;es-plugins&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    }]</code></pre><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data</code>这个目录中。</p><h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>需要资料中的ik分词器解压缩，重命名为ik</p><h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data</code>：</p><h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><pre><code class="shell"># 4、重启容器docker restart es</code></pre><pre><code class="sh"># 查看es日志docker logs -f es</code></pre><h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p>IK分词器包含两种模式：</p><ul><li><p><code>ik_smart</code>：最少切分</p></li><li><p><code>ik_max_word</code>：最细切分</p></li></ul><pre><code class="json">GET /_analyze{  &quot;analyzer&quot;: &quot;ik_max_word&quot;,  &quot;text&quot;: &quot;程序员学习java&quot;}</code></pre><h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><p>词汇不断的更新，IK分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录：</p><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt;        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;        &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt;</code></pre><p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><p>4）重启elasticsearch </p><pre><code class="sh">docker restart es# 查看 日志docker logs -f elasticsearch</code></pre><p>日志中已经成功加载ext.dic配置文件</p><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p><h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt;        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;        &lt;!--用户可以在这里配置自己的扩展字典--&gt;        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;         &lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;        &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt;</code></pre><p>3）在 stopword.dic 添加停用词</p><p>4）重启elasticsearch </p><pre><code class="sh"># 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch</code></pre><p>日志中已经成功加载stopword.dic配置文件</p><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p><h1 id="4-部署es集群"><a href="#4-部署es集群" class="headerlink" title="4.部署es集群"></a>4.部署es集群</h1><p>部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有<strong>4G</strong>的内存空间</p><p>首先写一个docker-compose文件，内容如下：</p><pre><code class="sh">version: &#39;2.2&#39;services:  es01:    image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1    container_name: es01    environment:      - node.name=es01      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es02,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data01:/usr/share/elasticsearch/data    ports:      - 9200:9200    networks:      - elastic  es02:    image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1    container_name: es02    environment:      - node.name=es02      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data02:/usr/share/elasticsearch/data    networks:      - elastic  es03:    image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1    container_name: es03    environment:      - node.name=es03      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es02      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data03:/usr/share/elasticsearch/data    networks:      - elasticvolumes:  data01:    driver: local  data02:    driver: local  data03:    driver: localnetworks:  elastic:    driver: bridge</code></pre><p>Run <code>docker-compose</code> to bring up the cluster:</p><pre><code class="sh">docker-compose up</code></pre>]]></content>
    
    <summary type="html">
    
      elasticsearch安装
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
</feed>
