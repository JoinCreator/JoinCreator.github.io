<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2022-03-10T07:28:58.569Z</updated>
  <id>/</id>
  
  <author>
    <name>ZHANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="/2022/03/10/a/"/>
    <id>/2022/03/10/a/</id>
    <published>2022-03-10T07:23:56.805Z</published>
    <updated>2022-03-10T07:28:58.569Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0">    <meta charset="utf-8">    <title>评论区留言</title>    <style type="text/css">        .div1,div{            width: 1350px;            margin:0 auto;        }    </style></head><body>    <div class="div1" id="div1">        <!-- 创建昵称和留言文本框 -->        <span>昵称：</span><input type="text" id="user" name="user">        <br>        <span>留言：</span><textarea id="lang"></textarea><br>        <!-- 创建提交评价按钮 -->        <input type="button" value="提交评价" id="btn">    </div></body><script type="text/javascript">    //通过id属性查找标签节点    var user=document.getElementById('user');    var lang=document.getElementById('lang');    //通过id属性查找提交评价按钮并绑定点击事件    document.getElementById('btn').onclick=function(){        //在html代码中创建一个div盒子        var cont=document.createElement('div');        //将获取到的数据，放到一创建好的盒子中        cont.innerHTML='<p>'+user.value+':'+lang.value+'</p><hr>';        //将创建好的div盒子及及内容显示在页面中        document.getElementById('div1').appendChild(cont);        user.value='';        lang.value='';    }</script></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.9.0&quot;&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;评论区留言&lt;/title&gt;
    &lt;style typ
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="/2022/03/10/abc/"/>
    <id>/2022/03/10/abc/</id>
    <published>2022-03-10T07:21:31.174Z</published>
    <updated>2022-03-10T07:23:30.818Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>HTML5实现留言和回复的页面-H5教程-PHP中文网</title><meta name="keywords" content="html5页面样式,HTML5"><meta name="description" content="这篇文章主要介绍了用HTML5如何实现留言和回复样式,需要的朋友可以参考下"><meta property="article:author" content="不言"><meta property="article:published_first" content=","><meta name="mobile-agent" content="format=html5;url=https://m.php.cn/article/402476.html"><meta http-equiv="Cache-Control" content="no-transform "><link rel="shortcut icon" href="/favicon.ico" mce_href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/static/layui/css/layui.css?1"><link rel="stylesheet" href="/static/css/style.min.css?5.2.47"><link rel="alternate" media="only screen and (max-width: 640px)" href="https://m.php.cn/article/402476.html"><!-- 让IE8/9支持媒体查询，从而兼容栅格 --><!--[if lt IE 9]><script src="https://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script><script src="https://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script><![endif]--><script>var is_mobi=navigator.userAgent.toLowerCase().match(/(ipod|ipad|iphone|android|coolpad|mmp|smartphone|midp|wap|xoom|symbian|j2me|blackberry|wince)/i)!=null;if(is_mobi){window.location.href="https://m.php.cn/article/402476.html";}var _czc = _czc || [];_czc.push(["_setAccount", "1280886301"]);</script><link rel="stylesheet" href="/static/ueditor/third-party/SyntaxHighlighter/shCoreDefault.css?1"><link rel="stylesheet" href="/static/ueditor/third-party/SyntaxHighlighter/shCoreDefault1.css"><style type="text/css">.layui-badge-dots{margin-right: 15px;width: 5px;height: 5px;background: #bbb!important;position: relative;display: inline-block;font-size: 12px;text-align: center;background-color: #FF5722;color: #fff;padding: 0;border-radius: 50%;}.relevant{color: #666;}.relevant:hover{color: #bbb}.php-article .detail-content-wrap th{background-color: #e9ecef;}.php-article .detail-content-wrap table{margin-bottom:15px;}.content ul li {list-style: unset;margin-left: 25px;font-size:16px;margin:8px 0 8px 30px;color:#3d464d;}.page ul li{list-style:none;font-size: 14px;margin-left: 0;}.content ul li p{padding:0!important;}.profile-info .layui-icon-auz{padding-left:10px;}.php-article .content h2{padding-left:10px;font-weight:600;}</style><script type="application/ld+json">{"@context": "https://zhanzhang.baidu.com/contexts/cambrian.jsonld","@id": "https://www.php.cn/html5-tutorial-402476.html","title": "HTML5实现留言和回复的页面","description": "这篇文章主要介绍了用HTML5如何实现留言和回复样式,需要的朋友可以参考下","images": ["https://img.php.cn/upload/article/000/000/009/5b1b8d78e5ba8969.jpg"],"pubDate": "2018-06-09T16:19:17","upDate": "2018-06-09T16:19:17"}</script></head><body class="site-home" id="LAY_home" style="background-color: #eee;"><div class="topimages"><a href="https://www.php.cn/course/1396.html" rel="nofollow" target="_blank"><img src="https://img.php.cn/upload/course/000/000/071/6228121210bf9428.jpg" style="left:50%;" alt="公益直播：4小时入门php，实战一个邮件发送系统"></a><i class="layui-icon layui-icon-close" title="关闭"></i></div><div class="layui-header header header-index"><div class="header-indexs-childs"><div class="php-logo"><a href="https://www.php.cn/" class="hide-text" title="php中文网" target="_blank" rel="noopener"></a></div><ul class="layui-nav php-nav"><li class="layui-nav-item "><a href="/" title="php中文网首页">首页</a><dl class="layui-nav-child"></dl></li><li class="layui-nav-item "><a href="/course.html" title="视频教程">视频教程 <i class="layui-icon layui-icon-down ft-12"></i></a><dl class="layui-nav-child"><dd><a href="/course.html" target="_blank">视频课程</a></dd><dd><a href="/course/type/8/live.html" target="_blank">直播课程</a></dd></dl></li><li class="layui-nav-item "><a href="javascript:;" title="学习路径" target="_blank" rel="noopener">学习路径 <i class="layui-icon layui-icon-down ft-12"></i></a><dl class="layui-nav-child"><dd><a href="/course/type/3.html" target="_blank">入门教程</a></dd><dd><a href="/map/dugu.html" target="_blank">独孤九贱</a></dd><dd><a href="/map/yunv.html" target="_blank">玉女心经</a></dd><dd><a href="/toutiao-409221.html" target="_blank">天龙八部</a></dd><dd><a href="/course/type/6.html" target="_blank">趣味闯关</a></dd></dl></li><li class="layui-nav-item"><a target="_blank" href="/k.html" title="PHP培训">PHP培训<img src="/static/images/new.png" width="17" height="12" class="HeaderKIcon"></a></li><li class="layui-nav-item"><a target="_blank" href="/xiazai/" title="资源下载">资源下载 <i class="layui-icon layui-icon-down ft-12"></i></a><dl class="layui-nav-child"><dd><a href="/xiazai/gongju" target="_blank" title="PHP工具">工具下载</a></dd><dd><a href="/xiazai/tool" target="_blank" title="在线工具">在线工具</a></dd><dd><a href="/xiazai/shouce" target="_blank" title="手册下载">手册下载</a></dd><dd><a href="/xiazai/learn" target="_blank" title="电子课件">电子课件</a></dd><dd><a href="/xiazai/js" target="_blank" title="js特效">js特效</a></dd><dd><a href="/xiazai/code" target="_blank" title="网站源码">网站源码</a></dd><dd><a href="/xiazai/sucai" target="_blank" title="网站素材">网站素材</a></dd><dd><a href="/xiazai/leiku" target="_blank" title="类库下载">类库下载</a></dd></dl></li><li class="layui-nav-item layui-hide-xs "><a href="/article.html" title="技术文章">技术文章 <i class="layui-icon layui-icon-down ft-12"></i></a><dl class="layui-nav-child"><dd><a href="/toutiao.html" target="_blank">头条</a></dd><dd><a href="/web-designer.html" target="_blank">前端开发</a></dd><dd><a href="/be/" target="_blank">后端开发</a></dd><dd><a href="/shujuku-tutorials.html" target="_blank">数据库</a></dd><dd><a href="/phpkj/" target="_blank">php框架</a></dd><dd><a href="/jishu/" target="_blank">每日编程</a></dd></dl></li><li class="layui-nav-item "><a href="javascript:;" title="社区问答" target="_blank" rel="noopener">社区 <i class="layui-icon layui-icon-down ft-12"></i></a><dl class="layui-nav-child"><dd><a href="/wenda.html" target="_blank">问答</a></dd><dd><a href="/blog.html" target="_blank">博客</a></dd></dl></li><li class="layui-nav-item "><a href="javascript:;" title="更多" target="_blank" rel="noopener"><img class="martop-4" src="/static/images/more.png" width="30"></a><dl class="layui-nav-child"><dd><a href="/dic.html" target="_blank">编程词典</a></dd><dd><a href="/app/" target="_blank">APP下载</a></dd></dl></li></ul><ul class="php-user"><li><span id="login">登录</span></li><li class="php-reg"><span id="reg">注册</span></li></ul><div class="layui-form component"><div class="layui-form-select"><div class="layui-select-title"><input type="text" id="key_words" placeholder="输入关键词搜索" onkeyup="keyup()" class="layui-input"><a href="javascript:;" onclick="searchs()" target="_blank" rel="noopener"><i class="layui-icon">&#xe615;</i></a></div></div></div><div class="clear"></div></div></div><div class="layui-main" style=" margin-top: 20px;"><div class="layui-row php-article"><div class="layui-col-md8 article-list-left"><div class="profile"><div><a href="/">首页</a> ><a href="/web-designer.html">web前端</a> ><a href="/html5-tutorial.html">H5教程</a> > 正文</div><h1>HTML5实现留言和回复的页面</h1><span title="是否原创"><i class="layui-icon">&#xe609;</i>原创</span><span><i class="layui-icon" title="添加时间">&#xe60e;</i>2018-06-09 16:19:17</span><span><i class="layui-icon" title="评论">&#xe63a;</i>0</span><span class="hot"><i class="layui-icon" title="浏览">&#xe756;</i>4519</span></div><div class="detail-content-wrap"><div class="content"><span class="content_article_viewer_show">这篇文章主要介绍了用HTML5如何实现留言和回复样式,需要的朋友可以参考下<p></p><p>具体就不做详细讲解了，直接上代码：</p><p class="jb51code"></p><pre class="brush:html;toolbar:false;">&lt;!DOCTYPE html&gt;    &lt;html&gt;    &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;http://www.webkfa.com/&quot; /&gt;    &lt;title&gt;web开发-webkfa.com&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;    *{    margin:0;padding:0;    -webkit-touch-callout: none; /* prevent callout to copy image, etc when tap to hold */    -webkit-text-size-adjust: none; /* prevent webkit from resizing text to fit */    -webkit-tap-highlight-color: rgba(210,210,210,0.35); /* make transparent link selection, adjust last value opacity 0 to 1.0 */    -webkit-user-select: none; /* prevent copy paste, to allow, change &#39;none&#39; to &#39;text&#39; */    }    body{font-family:&quot;微软雅黑&quot;;font-size:12px;}    ul,li{list-style:none;}    .ylcon{width:100%;min-width:320px;}    .tit{height:26px;line-height:26px;padding:0px 15px;position:relative;font-size:15px;color:#aaa;border-bottom:1px solid rgba(0, 0, 0, 0.15);}        .story{border-bottom:1px dashed #cecece;padding:0 15px 3px;position:relative;}    .story_t{font-size:1.2em;color:rgba(0,0,0,1);padding-top:5px;padding-bottom:2px;}    .story_m{color:rgba(110,110,110,1);line-height:21px;word-break:break-all;word-wrap:break-word;overflow:hidden;font-size:1.2em;padding:2px 0;}    .story_time{color:rgba(154,154,154,1);padding:2px 0;}    .story_hf{background:rgb(245,245,245);font-size:1.2em;border:1px solid rgba(204,204,204,0.2);border-radius:2px;color:rgba(110,110,110,1);padding:4px;margin-bottom:5px;}    .opbtn{position:absolute;top: 0;right: 0;}    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;p class=&quot;ylcon&quot;&gt;    &lt;p class=&quot;tit&quot;&gt;    所有留言    &lt;/p&gt;    &lt;p id=&quot;messpId&quot;&gt;    &lt;p class=&quot;story&quot;&gt;    &lt;p class=&quot;opbtn&quot;&gt;&lt;/p&gt;    &lt;p class=&quot;story_t&quot;&gt;怜星&lt;/p&gt;    &lt;p class=&quot;story_time&quot;&gt;2015/07/12 20:48&lt;/p&gt;    &lt;p class=&quot;story_m&quot;&gt;我想问最近最火的tfboys呢他们的八卦呢我想问最近最火的tfboys呢,他们的八卦呢我想问最近最火的tfboys呢？！他们的八卦呢？！&lt;/p&gt;    &lt;p class=&quot;story_hf&quot;&gt;@剑花烟雨:的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契&lt;/p&gt;    &lt;/p&gt;    &lt;p class=&quot;story&quot;&gt;    &lt;p class=&quot;opbtn&quot;&gt;&lt;/p&gt;    &lt;p class=&quot;story_t&quot;&gt;怜星&lt;/p&gt;    &lt;p class=&quot;story_time&quot;&gt;2015/07/12 20:48&lt;/p&gt;    &lt;p class=&quot;story_m&quot;&gt;我想问最近最火的tfboys呢他们的八卦呢我想问最近最火的tfboys呢,他们的八卦呢我想问最近最火的tfboys呢？！他们的八卦呢？！&lt;/p&gt;    &lt;p class=&quot;story_hf&quot;&gt;@剑花烟雨:的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契&lt;/p&gt;    &lt;/p&gt;    &lt;p class=&quot;story&quot;&gt;    &lt;p class=&quot;opbtn&quot;&gt;&lt;/p&gt;    &lt;p class=&quot;story_t&quot;&gt;怜星&lt;/p&gt;    &lt;p class=&quot;story_time&quot;&gt;2015/07/12 20:48&lt;/p&gt;    &lt;p class=&quot;story_m&quot;&gt;我想问最近最火的tfboys呢他们的八卦呢我想问最近最火的tfboys呢,他们的八卦呢我想问最近最火的tfboys呢？！他们的八卦呢？！&lt;/p&gt;    &lt;p class=&quot;story_hf&quot;&gt;@剑花烟雨:的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契&lt;/p&gt;    &lt;/p&gt;    &lt;/p&gt;    &lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;</pre><p></p><p>以上就是本文的全部内容，希望对大家的学习有所帮助，更多相关内容请关注PHP中文网！</p><p>相关推荐：</p><p><a href="http://www.php.cn/html5-tutorial-400928.html" target="_blank">html5生成柱状图(条形图)效果的实例代码</a><br></p><p><a href="http://www.php.cn/html5-tutorial-402409.html" target="_blank">如何利用HTML5实现分享到微信好友朋友圈QQ好友QQ空间微博二维码的功能</a><br></p><p></p><p class="clearfix"><span class="jbTestPos"></span></p><p>以上就是HTML5实现留言和回复的页面的详细内容，更多请关注php中文网其它相关文章！</p></span><div class="share layui-clear bdsharebuttonbox"><li><a href="javascript:;" data-cmd="weixin" class="wechat" target="_blank" rel="noopener"><i class="layui-icon">&#xe63a;</i>微信</a></li><li><a href="javascript:;" data-cmd="more" class="share-btn" target="_blank" rel="noopener"><i class="layui-icon">&#xe641;</i>分享</a></li></div><!--<img src="/static/images/article_wechat2021.jpg?1111" style="margin-top: 30px;" alt="php中文网最新课程二维码"/>--><a href="/k.html?t=2" target="_blank"><img src="https://img.php.cn/upload/course/000/000/071/621c239fc661a260.png" style="margin-top: 30px;" alt="php中文网直播班"></a><!--<a href="/app/" target="_blank"><img src="https://img.php.cn/upload/article/000/000/003/61ebc642cf61c488.png" style="margin-top: 30px;" alt="php中文网APP下载"/></a>--><p style="float:right;font-size:13px;color:#999;"><span class="red">声明：</span>本文内容由网友自发贡献，版权归原作者所有，本站不承担相应法律责任。如您发现有涉嫌抄袭侵权的内容，请联系admin@php.cn核实处理。</p><div class="tags layui-clear"><li>相关标签：<a href="/search?word=html5页面样式" target="_blank">html5页面样式</a> <a href="/search?word=html5" target="_blank">HTML5</a></li><li class="line"></li></div><div class="page layui-clear"><ul><li>上一篇：<a href="/html5-tutorial-402462.html">如何在微信端html5页面调用分享接口</a></li><li>下一篇：<a href="/html5-tutorial-402500.html">HTML5实现使用按钮控制背景音乐开关的方法</a></li></ul></div></div><p class="article-relative-header">相关文章</p><p class="article-relative-header">相关视频</p><hr class="layui-clear"><ul class="article-relative-ul"><li><span class="layui-badge-dots"></span><a class="relevant" href="/html5-tutorial-485134.html" target="_blank">html5离线存储有哪些</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/html5-tutorial-481308.html" target="_blank">深入解析asp.net中mvc4自定义404页面（...</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/html5-tutorial-112721.html" target="_blank">在今天，利用 HTML5 开发和发布大型跨平台网游...</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/html5-tutorial-35776.html" target="_blank">避免常见的六种HTML5错误用法 (5-6)</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/html5-tutorial-402476.html">HTML5实现留言和回复的页面</a></li></ul><ul class="article-relative-ul"><li><span class="layui-badge-dots"></span><a class="relevant" href="/code/557.html" target="_blank" title="HTML5浏览器支持">HTML5浏览器支持</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/code/565.html" target="_blank" title="HTML5新元素">HTML5新元素</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/code/581.html" target="_blank" title="HTML5内联SVG">HTML5内联SVG</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/code/586.html" target="_blank" title="HTML5 MathML">HTML5 MathML</a></li><li><span class="layui-badge-dots"></span><a class="relevant" href="/code/609.html" target="_blank" title="HTML5 拖放">HTML5 拖放</a></li></ul><div class="layui-clear"></div></div><div class="comment layui-clear CopyrightData"><div class="J_Header" id="J_Header"><p class="header-title">网友评论</p><p class="header-protocol">文明上网理性发言，请遵守 <a href="javascript:void(0);" target="_blank" rel="noopener">新闻评论服务协议</a></p><a class="article-comment-publish" href="javascript:void(0);" target="_blank" rel="noopener">我要评论</a></div><div class="layui-row diy-page"></div><div class="text-box layui-clear article_comment_textarea"><div class="box-left"><li><a href="javascript:login_trigger()" target="_blank" rel="noopener"><img src="/static/images/user_avatar.jpg" alt></a></li><li><a href="javascript:login_trigger()" target="_blank" rel="noopener"></a></li></div><div class="box-right"><textarea name="desc" placeholder="请输入内容" class="layui-textarea article_textarea"></textarea><button class="layui-btn article_publish" data-id="402476">立即提交</button></div></div></div><div class="article-hot layui-clear" style="margin-top:0"><h2>专题推荐</h2><ul><li><a href="/map/dugu.html" target="_blank"><img src="https://img.php.cn/upload/article/000/000/003/5d1ef1e9e866e635.jpg"></a><a class="course-title" href="/map/dugu.html" target="_blank">独孤九贱-php全栈开发教程</a><p class="course-type">全栈 <i class="layui-icon layui-icon-user"></i> 170W+</p><p class="course-des">主讲：Peter-Zhu  轻松幽默、简短易学，非常适合PHP学习入门</p></li><li><a href="/map/yunv.html" target="_blank"><img src="https://img.php.cn/upload/article/000/000/003/5d1ef236ca878949.jpg"></a><a class="course-title" href="/map/yunv.html" target="_blank">玉女心经-web前端开发教程</a><p class="course-type">入门 <i class="layui-icon layui-icon-user"></i> 80W+</p><p class="course-des">主讲：灭绝师太  由浅入深、明快简洁，非常适合前端学习入门</p></li><li><a href="/toutiao-409221.html" target="_blank"><img src="https://img.php.cn/upload/article/000/000/003/5d1ef2477c7d7587.jpg"></a><a class="course-title" href="/toutiao-409221.html" target="_blank">天龙八部-实战开发教程</a><p class="course-type">实战 <i class="layui-icon layui-icon-user"></i> 120W+</p><p class="course-des">主讲：西门大官人 思路清晰、严谨规范，适合有一定web编程基础学习</p></li></ul><div class="clear"></div></div></div><div class="layui-col-md4 article-list-right "><div class="panel"><div class="panel-title">作者信息</div><div id="profile-2"><div class="avatar-wrap"><a href="/member/153291.html" target="_blank" class="avatar-link"><img src="https://img.php.cn/upload/avatar/000/153/291/5c42bb52b397e610.jpg" class="func-um_user gravatar avatar avatar-120 um-avatar um-avatar-uploaded"></a></div><div class="profile-info"><p><span class="author-name">不言</span><i class="layui-icon layui-icon-auz" title="认证作者"></i></p><p class="author-description">认证0级讲师</p><div class="author-article"><dl class="list-one"><dt class="panel-title">最近文章</dt><dd><a href="/faq/417293.html" target="_blank" title="查找的快捷键是ctrl键加上什么键">查找的快捷键是ctrl键加上什么键</a><span><i class="layui-icon layui-icon-fire"></i>229278</span></dd><dd><a href="/faq/417285.html" target="_blank" title="剪切快捷键ctrl加什么？">剪切快捷键ctrl加什么？</a><span><i class="layui-icon layui-icon-fire"></i>374480</span></dd><dd><a href="/faq/417276.html" target="_blank" title="it是什么职业？">it是什么职业？</a><span><i class="layui-icon layui-icon-fire"></i>44076</span></dd></dl></div></div></div></div><div class="layui-clear"><a href="javascript:publish_article()" class="layui-btn layui-btn-danger article-add" target="_blank" rel="noopener">发布技术文章</a></div><div class="top-article layui-clear"><div class="layui-tab layui-tab-card"><ul class="layui-tab-title"><li class="layui-this">最新文章</li><li>热门排行</li></ul><div class="layui-tab-content"><div class="layui-tab-item layui-show"><ul><p class="top-img"><!--<a href='/vip.html' target="_blank" title='VIP会员'><img src='https://img.php.cn/upload/article/000/000/003/5f4de931a5deb813.png' style="width: 100%"></a>--><a href="https://www.php.cn/k.html?t=2" target="_blank" title="线上直播班"><img src="https://img.php.cn/upload/course/000/000/071/621c2291d2dc2919.png" style="width: 100%"></a><!--<a href='https://www.php.cn/q.html' target="_blank" title='大前端线上直播班'><img src='https://img.php.cn/upload/article/000/000/001/61760a80eefec303.png' style="width: 100%"></a>--></p><li><a href="/html5-tutorial-485290.html" target="_blank" title="html5的doctype声明是什么">html5的doctype声明是什么</a></li><li><a href="/html5-tutorial-485276.html" target="_blank" title="html5编辑器有哪些">html5编辑器有哪些</a></li><li><a href="/html5-tutorial-485134.html" target="_blank" title="html5离线存储有哪些">html5离线存储有哪些</a></li><li><a href="/html5-tutorial-484442.html" target="_blank" title="html5新增了什么">html5新增了什么</a></li><li><a href="/html5-tutorial-483489.html" target="_blank" title="h5新增标签audio与video的使用">h5新增标签audio与video的使用</a></li><li><a href="/html5-tutorial-481662.html" target="_blank" title="html5 app开发框架有哪些">html5 app开发框架有哪些</a></li><li><a href="/html5-tutorial-481607.html" target="_blank" title="你值得了解的WEB前端跨域解决方案（代码详解）">你值得了解的WEB前端跨域解决方案（代码详解）</a></li><li><a href="/html5-tutorial-481408.html" target="_blank" title="手把手教你使用给站点开启https和http2（附代码）">手把手教你使用给站点开启https和http2（附代码）</a></li></ul></div><div class="layui-tab-item"><ul><p class="top-img"><a href="/toutiao-387072.html" target="_blank" title="面对巨额亏损的PHP中文网，我该为情怀买单吗？（猪哥）"><img src="https://img.php.cn/upload/article/000/000/003/5b890a9e4417f872.png" style="width: 100%"></a></p><li><a href="/html5-tutorial-414835.html" target="_blank" title="h5是什么">h5是什么</a></li><li><a href="/html5-tutorial-413675.html" target="_blank" title="app是什么意思">app是什么意思</a></li><li><a href="/html5-tutorial-413480.html" target="_blank" title="什么是前端和后端">什么是前端和后端</a></li><li><a href="/html5-tutorial-417718.html" target="_blank" title="不懂代码怎么制作h5页面？H5页面制作平台推荐">不懂代码怎么制作h5页面？H5页面制作平台推荐</a></li><li><a href="/html5-tutorial-359814.html" target="_blank" title="Google AMP 是什么鬼？">Google AMP 是什么鬼？</a></li><li><a href="/html5-tutorial-357181.html" target="_blank" title="HTML5开发实例-3D全景(ThreeJs全景Demo) 详解（图）">HTML5开发实例-3D全景(ThreeJs全景Demo) 详解（图）</a></li><li><a href="/html5-tutorial-403035.html" target="_blank" title="HTML5如何实现视频直播功能">HTML5如何实现视频直播功能</a></li><li><a href="/html5-tutorial-412500.html" target="_blank" title="如何用HTML5在页面中插入可自动播放的视频">如何用HTML5在页面中插入可自动播放的视频</a></li></ul></div></div></div></div><!----><!--<div class="article-coursephp-news-right-imginfo">--><!--<a href="https://s.click.taobao.com/HSS8Uau" rel="nofllow" target="_blank" >--><!--<img src='https://img.php.cn/upload/course/000/000/071/621b3be8266ab384.jpg'  width='340'>--><!--</a>--><!--</div>--><!----><div class="article-ad article-course php-news-right-imginfo"><div class="r-title"><i class="layui-icon layui-icon-praise"></i>推荐视频教程</div><li><a href="/course/179.html" target="_blank"><img src="https://img.php.cn/upload/course/000/000/003/5a17982d48686254.jpg" alt="javascript初级视频教程" height="60"></a><span><a href="/course/179.html" target="_blank">javascript初级视频教程</a></span></li><li><a href="/course/181.html" target="_blank"><img src="https://img.php.cn/upload/course/000/000/003/5a179283c3885703.jpg" alt="jquery 基础视频教程" height="60"></a><span><a href="/course/181.html" target="_blank">jquery 基础视频教程</a></span></li></div><div class="article-ad mt-20" id="aritcle_detail_new"><div class="r-title"><i class="layui-icon layui-icon-video"></i>视频教程分类</div><ul class="course-category-lists layui-clear"><li><a href="/course/list/29/type/2.html" target="_blank"><div class="course-category-child-first">php视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/11.html" target="_blank"><div class="course-category-child-first">html视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/12.html" target="_blank"><div class="course-category-child-first">css视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/17.html" target="_blank"><div class="course-category-child-first">JS视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/19.html" target="_blank"><div class="course-category-child-first">jQuery视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/51.html" target="_blank"><div class="course-category-child-first">mysql视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/33.html" target="_blank"><div class="course-category-child-first">Linux视频教程</div><div class="course-category-child"></div></a></li><li><a href="/course/list/30.html" target="_blank"><div class="course-category-child-first">Python视频教程</div><div class="course-category-child"></div></a></li></ul></div></div></div></div><!--技术文章--><script src="/static/ueditor/third-party/SyntaxHighlighter/shCore.js?3.1.1"></script><script>article_status = 153291;</script><script type="text/javascript" src="/static/js/jquery.min.js"></script><script src="https://vdse.bdstatic.com//search-video.v1.min.js"></script><iframe src="/adapp1.html?1646896827" frameborder="0" style="position: fixed;bottom:0;right:0;z-index:99999;"></iframe><div class="layui-clear layui-bg-black php-ul-li footer_top_margin"><div class="layui-row  layui-main"><div class="layui-col-md9"><ul class="php-float-left"><li><a href="/" target="_blank" title="网站首页">网站首页 </a></li><li><a href="/course/list/29/type/2.html" target="_blank" title="PHP视频">PHP视频</a></li><li><a href="/course/list/29/type/4.html" target="_blank" title="PHP实战">PHP实战</a></li><li><a href="/course/list/29/type/1.html" target="_blank" title="PHP代码">PHP代码</a></li><li><a href="/course/list/29/type/3.html" target="_blank" title="PHP手册">PHP手册</a></li><li><a href="/wikis.html" target="_blank" title="词条">词条</a></li><li><a href="/write.html" target="_blank" title="手记">手记</a></li><li><a href="/dic.html" target="_blank" title="手记">编程词典</a></li><li><a href="/k.html" target="_blank">php培训</a></li></ul><p class="layui-clear footer_phpcn">php中文网：公益在线php培训，帮助PHP学习者快速成长！</p><p class="footer_phpcn_record">Copyright 2014-2021 https://www.php.cn/ All Rights Reserved | <a href="https://beian.miit.gov.cn/" style="color: #9c9c9c;" rel="nofollow" target="_blank">苏ICP备2020058653号-1</a><a href="http://112.30.63.109:8887/showEi?id=6a58f74d17984675aa1b671d0fa101cf&url=php.cn" rel="nofollow" target="_blank"><img src="/static/images/foot_line.gif" width="15"></a><span class="footer_phpcn_say" style="padding-left:15px;"><a href="/about/us.html" target="_blank">关于我们</a><a href="/about/disclaimer.html" target="_blank" class="mr10">免责申明</a><a href="/about/donate.html" class="mr10" target="_blank">赞助与捐赠</a><a href="/blog/detail/20304.html" target="_blank">广告合作</a></span></p></div><div class="layui-col-md3" style="padding-top:15px;"><img src="/static/images/phpcn_erwei.jpg" width="100">&nbsp;&nbsp;                <img src="/static/images/qq.jpg" width="100"></div></div></div><style>.layui-fixbar{bottom:200px;}</style><input type="hidden" id="verifycode" value="/captcha.html"><script src="/static/js/jquery.min.js"></script><script src="/static/layui/layui.js"></script><script type="text/javascript" src="/static/js/global.min.js?5.4.93"></script><script>var _hmt = _hmt || [];(function(){var hm = document.createElement("script");hm.src="//hm.baidu.com/hm.js?aaf8dba0861f46190106021371583c62";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();(function(){var bp = document.createElement('script');var curProtocol = window.location.protocol.split(':')[0];if(curProtocol === 'https'){bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';}else{bp.src = 'http://push.zhanzhang.baidu.com/push.js';};var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp, s);})();</script><script type="text/javascript" src="/static/js/jquery.cookie.js"></script><script>var topadshow = $.cookie('phpcndatatopadshows');if(!topadshow&&1==2){$('.topimages').show();var topobj = $('.topimages').find('.time');var topobj_day = $('.topimages .time').find('.day');var topobj_hours = $('.topimages .time').find('.hours');var topobj_minutes = $('.topimages .time').find('.minutes');var topobj_second = $('.topimages .time').find('.second');var topday = parseInt(topobj_day.html());var tophours = parseInt(topobj_hours.html());var topminutes = parseInt(topobj_minutes.html());var topsecond = parseInt(topobj_second.html());setInterval(function(){if(topsecond > 0){topsecond = topsecond-1;}else{if(topminutes > 0){topminutes = topminutes-1;topsecond = 59;}else{if(tophours > 0){tophours = tophours-1;topminutes = 59;topsecond = 59;}else{if(topday > 0){topday = topday -1;tophours = 23;topminutes = 59;topsecond = 59;}else{topobj.html("<p><span>活动已结束</span></p>");}}}}topobj_second.html(topsecond);topobj_minutes.html(topminutes);topobj_hours.html(tophours);topobj_day.html(topday);},1000);}$('.topimages .layui-icon-close').click(function(){$.cookie('phpcndatatopadshows',1,{expires:7});$('.topimages').hide();});</script><link rel="stylesheet" id="_main-css" href="/static/css/viewer.min.css?2" type="text/css" media="all"><script type="text/javascript" src="/static/js/viewer.min.js?1"></script><script type="text/javascript" src="/static/js/jquery-viewer.min.js"></script><script>$('.content_article_viewer_show').viewer();</script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.9.0&quot;&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-wi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="/2022/03/10/String/"/>
    <id>/2022/03/10/String/</id>
    <published>2022-03-10T02:02:08.797Z</published>
    <updated>2022-03-10T02:03:32.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h3><h4 id="一-常用方法"><a href="#一-常用方法" class="headerlink" title="一.常用方法"></a>一.常用方法</h4><ul><li><pre><code class="java">package com.test03;/** * Settings-Editor-File and Code Templates */public class StringTest {        public static void main(String[] args) {//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写            String str1 = &quot;hello&quot;;            String str2 = &quot;Hello&quot;;            System.out.println(str1.equals(str2));//// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等            String username = &quot;johN&quot;;            if (&quot;john&quot;.equalsIgnoreCase(username)) {                System.out.println(&quot;Success!&quot;);            } else {                System.out.println(&quot;Failure!&quot;);            }// 3.length 获取字符的个数，字符串的长度            System.out.println(&quot;韩顺平&quot;.length());// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1            String s1 = &quot;wer@terwe@g&quot;;            int index = s1.indexOf(&#39;@&#39;);            System.out.println(index);// 3            System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1            s1 = &quot;wer@terwe@g@&quot;;            index = s1.lastIndexOf(&#39;@&#39;);            System.out.println(index);//11            System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4// 6.substring 截取指定范围的子串            String name = &quot;hello,张三&quot;;//下面 name.substring(6) 从索引 6 开始截取后面所有的内容            System.out.println(name.substring(6));//截取后面的字符//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置            System.out.println(name.substring(2,5));//llo        }}</code></pre></li></ul><pre><code class="java">package com.test03;/** * Settings-Editor-File and Code Templates */public class StringTest02 {        public static void main(String[] args) {// 1.toUpperCase 转换成大写            String s = &quot;heLLo&quot;;            System.out.println(s.toUpperCase());//HELLO// 2.toLowerCase            System.out.println(s.toLowerCase());//hello// 3.concat 拼接字符串            String s1 = &quot;宝玉&quot;;            s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;);            System.out.println(s1);//宝玉林黛玉薛宝钗 together// 4.replace 替换字符串中的字符            s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;;//在 s1 中，将 所有的 林黛玉 替换成薛宝钗//  s1.replace() 方法执行后，返回的结果才是替换过的.// 注意对 s1 没有任何影响            String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;);            System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉            System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等            String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \            String[] split = poem.split(&quot;,&quot;);            poem = &quot;E:\\aaa\\bbb&quot;;            split = poem.split(&quot;\\\\&quot;);            System.out.println(&quot;==分割后内容===&quot;);            for (int i = 0; i &lt; split.length; i++) {                System.out.println(split[i]);            }// 6.toCharArray 转换成字符数组                    s = &quot;happy&quot;;            char[] chs = s.toCharArray();            for (int i = 0; i &lt; chs.length; i++) {                System.out.println(chs[i]);            }// 7.compareTo 比较两个字符串的大小，如果前者大，// 则返回正数，后者大，则返回负数，如果相等，返回 0// (1) 如果长度相同，并且每个字符也相同，就返回 0// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小// 就返回 if (c1 != c2) {// return c1 - c2;// }// (3) 如果前面的部分都相同，就返回 str1.len - str2.len            String a = &quot;jcck&quot;;// len = 3            String b = &quot;jack&quot;;// len = 4            System.out.println(a.compareTo(b)); // 返回值是 &#39;c&#39; - &#39;a&#39; = 2 的值// 8.format 格式字符串            /* 占位符有:             * %s 字符串 %c 字符 %d 整型 %.2f 浮点型             *             */            String name = &quot;john&quot;;            int age = 10;            double score = 56.857;            char gender = &#39;男&#39;;//将所有的信息都拼接在一个字符串.            String info =                    &quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！ &quot;;            System.out.println(info);//1. %s , %d , %.2f %c 称为占位符//2. 这些占位符由后面变量来替换//3. %s 表示后面由 字符串来替换//4. %d 是整数来替换//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理//6. %c 使用 char 类型来替换            String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;;            String info2 = String.format(formatStr, name, age, score, gender);            System.out.println(&quot;info2=&quot; + info2);        }}</code></pre><h3 id="StringBuffer-类："><a href="#StringBuffer-类：" class="headerlink" title="StringBuffer 类："></a>StringBuffer 类：</h3><pre><code class="java">public class StringBuffer01 {public static void main(String[] args) {//1. StringBuffer 的直接父类 是 AbstractStringBuilder//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final// 该 value 数组存放 字符串内容，引出存放在堆中的//4. StringBuffer 是一个 final 类，不能被继承//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 StringStringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);}}</code></pre><h4 id="String-VS-StringBuffer"><a href="#String-VS-StringBuffer" class="headerlink" title="String VS StringBuffer"></a>String VS StringBuffer</h4><p>1) String保存的是字符串常量，里面的值不能更改，每次String类的更新实际<br>上就是更改地址， 效率较低//private final char value[];<br>2) StringBuffer保存的是字符串变量，里面的值可以更改，每次<br>StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高<br>//char[] value; /这个放在堆</p><h4 id="String-和-StringBuffer-相互转换"><a href="#String-和-StringBuffer-相互转换" class="headerlink" title="String 和 StringBuffer 相互转换"></a>String 和 StringBuffer 相互转换</h4><ul><li><p><code>`</code>java<br>public class StringAndStringBuffer {<br>public static void main(String[] args) {<br>//看 String——&gt;StringBuffer</p><p>String str = “hello tom”;<br>//方式 1 使用构造器<br>//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响<br>StringBuffer stringBuffer = new StringBuffer(str);<br>//方式 2 使用的是 append 方法<br>StringBuffer stringBuffer1 = new StringBuffer();<br>stringBuffer1 = stringBuffer1.append(str);<br>//看看 StringBuffer -&gt;String<br>StringBuffer stringBuffer3 = new StringBuffer(“韩顺平教育”);<br>//方式 1 使用 StringBuffer 提供的 toString 方法<br>String s = stringBuffer3.toString();<br>//方式 2: 使用构造器来搞定<br>String s1 = new String(stringBuffer3);<br>}<br>}<br>13.5.4 StringBuffer 类常见方法<br>package com.hspedu.stringbuffer_;</p></li></ul><pre><code>public class StringBufferMethod {public static void main(String[] args) {StringBuffer s = new StringBuffer(&quot;hello&quot;);//增s.append(&#39;,&#39;);// &quot;hello,&quot;s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot;System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot;//删/*</code></pre><ul><li>删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</li><li><p>解读: 删除 11~14 的字符 [11, 14)<br>*/<br>s.delete(11, 14);<br>System.out.println(s);//“hello,张三丰赵敏 true10.5”<br>//改<br>//，使用 周芷若 替换 索引 9-11 的字符 [9,11)<br>s.replace(9, 11, “周芷若”);<br>System.out.println(s);//“hello,张三丰周芷若 true10.5”<br>//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1<br>int indexOf = s.indexOf(“张三丰”);<br>System.out.println(indexOf);//6<br>//插</p><p>//，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移<br>s.insert(9, “赵敏”);<br>System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”<br>//长度<br>System.out.println(s.length());//22<br>System.out.println(s);<br>}<br>}</p><p><code>`</code></p><h4 id="StringBuffer-类常见方法"><a href="#StringBuffer-类常见方法" class="headerlink" title="StringBuffer 类常见方法"></a>StringBuffer 类常见方法</h4><p><code>`</code>java</p></li><li><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p>public class StringBufferMethod {<br>public static void main(String[] args) {<br>StringBuffer s = new StringBuffer(“hello”);<br>//增<br>s.append(‘,’);// “hello,”<br>s.append(“张三丰”);//“hello,张三丰”<br>s.append(“赵敏”).append(100).append(true).append(10.5);//“hello,张三丰赵敏 100true10.5”<br>System.out.println(s);//“hello,张三丰赵敏 100true10.5”<br>//删<br>/*</p></li><li><p>删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</p></li><li><p>解读: 删除 11~14 的字符 [11, 14)<br>*/<br>s.delete(11, 14);<br>System.out.println(s);//“hello,张三丰赵敏 true10.5”<br>//改<br>//，使用 周芷若 替换 索引 9-11 的字符 [9,11)<br>s.replace(9, 11, “周芷若”);<br>System.out.println(s);//“hello,张三丰周芷若 true10.5”<br>//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1<br>int indexOf = s.indexOf(“张三丰”);<br>System.out.println(indexOf);//6<br>//插</p><p>//，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移<br>s.insert(9, “赵敏”);<br>System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”<br>//长度<br>System.out.println(s.length());//22<br>System.out.println(s);<br>}<br>}<br><code>`</code></p></li></ul><h4 id="StringBuffer-类测试题-1-StringBufferExercise01-java"><a href="#StringBuffer-类测试题-1-StringBufferExercise01-java" class="headerlink" title="StringBuffer 类测试题 1 StringBufferExercise01.java"></a>StringBuffer 类测试题 1 StringBufferExercise01.java</h4><pre><code class="java">public class StringBufferExercise01 {public static void main(String[] args) {String str = null;// okStringBuffer sb = new StringBuffer(); //oksb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNullSystem.out.println(sb.length());//4System.out.println(sb);//null韩顺平学 循序渐进学 Java 零基础第 561页//下面的构造器，会抛出 NullpointerExceptionStringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);System.out.println(sb1);}}</code></pre><pre><code class="java">public class StringBufferExercise02 {public static void main(String[] args) {/*输入商品名称和商品价格，要求打印效果示例, 使用前面学习的方法完成：商品名 商品价格手机 123,564.59 //比如 价格 3,456,789.88要求：价格的小数点前面每三位用逗号隔开, 在输出。思路分析1. 定义一个 Scanner 对象，接收用户输入的 价格(String)2. 希望使用到 StringBuffer 的 insert ，需要将 String 转成 StringBuffer3. 然后使用相关方法进行字符串的处理   代码实现   */   //new Scanner(System.in)   String price = &quot;8123564.59&quot;;   StringBuffer sb = new StringBuffer(price);   //先完成一个最简单的实现 123,564.59   //找到小数点的索引，然后在该位置的前 3 位，插入,即可   // int i = sb.lastIndexOf(&quot;.&quot;);   // sb = sb.insert(i - 3, &quot;,&quot;);   //上面的两步需要做一个循环处理,才是正确的   for (int i = sb.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0; i -= 3) {   sb = sb.insert(i, &quot;,&quot;);   }   System.out.println(sb);//8,123,564.59   }   }</code></pre><p>StringBuilder01 java<br>1)一个可变的字符序列。此类提供一个与StringBuffer兼容的API,但不保证同<br>步(StringBuilder不是线程安全)。该类被设计用作StringBuffer的一个简易<br>替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类<br>因为在大多数实现中，它比StringBuffer要快[后面测]。<br>2)在StringBuilder上的主要操作是append和insert方法，可重载这些方法，<br>以接受任意类型的数据。</p><pre><code class="java">public class StringBuffer01 {public static void main(String[] args) {//1. StringBuffer 的直接父类 是 AbstractStringBuilder//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final// 该 value 数组存放 字符串内容，引出存放在堆中的//4. StringBuffer 是一个 final 类，不能被继承//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 StringStringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;);}}</code></pre><pre><code class="java">public class StringBuilder01 {public static void main(String[] args) {//1. StringBuilder 继承 AbstractStringBuilder 类//2. 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件)//3. StringBuilder 是 final 类, 不能被继承//4. StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value;// 因此，字符序列是堆中//5. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用// StringBuilderStringBuilder stringBuilder = new StringBuilder();}}</code></pre><p> String、StringBuffer 和 StringBuilder 的比较</p><p>1) StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法<br>也一样<br>2) String: 不可变字符序列，效率低,但是复用率高。<br>3) StringBuffer: 可变字符序列、效率较高(增删)、线程安全，看源码<br>4) StringBuilder: 可变字符序列、效率最高、线程不安全<br>5) String使用注意说明:<br>string s= “a”; //创建了一个字符串<br>s += “b”; //实际上原来的” a”字符串对象已经丢弃了，现在又产生了一个字符I<br>串s+”b” (也就是”ab”)。 如果多次执行这些改变串内容的操作，会导致大量副<br>本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大<br>影响程序的性能=&gt;结论:如果我们对String做大量修改，不要使用String</p><h4 id="String、StringBuffer-和-StringBuilder-的选择"><a href="#String、StringBuffer-和-StringBuilder-的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder 的选择"></a>String、StringBuffer 和 StringBuilder 的选择</h4><p>使用的原则， 结论:<br>1.如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder<br>2.如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder<br>3.如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer<br>4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等<br>StringBuilder的方法使用和StringBuffer一样</p><h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><h4 id="Math-类常见方法"><a href="#Math-类常见方法" class="headerlink" title="Math 类常见方法"></a>Math 类常见方法</h4><pre><code class="java">public class MathMethod {public static void main(String[] args) {//看看 Math 常用的方法(静态方法)//1.abs 绝对值int abs = Math.abs(-9);System.out.println(abs);//9//2.pow 求幂double pow = Math.pow(2, 4);//2 的 4 次方System.out.println(pow);//16//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);double ceil = Math.ceil(3.9);System.out.println(ceil);//4.0//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)double floor = Math.floor(4.001);System.out.println(floor);//4.0//5.round 四舍五入 Math.floor(该参数+0.5)long round = Math.round(5.51);System.out.println(round);//6//6.sqrt 求开方double sqrt = Math.sqrt(9.0);System.out.println(sqrt);//3.0//7.random 求随机数// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7// 即返回一个数 x 2 &lt;= x &lt;= 7//  Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )for(int i = 0; i &lt; 100; i++) {System.out.println((int)(2 + Math.random() * (7 - 2 + 1)));}//max , min 返回最大值和最小值int min = Math.min(1, 9);int max = Math.max(45, 90);System.out.println(&quot;min=&quot; + min);System.out.println(&quot;max=&quot; + max);}}</code></pre><h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><h4 id="Arrays-类常见方法应用"><a href="#Arrays-类常见方法应用" class="headerlink" title="Arrays 类常见方法应用"></a>Arrays 类常见方法应用</h4><pre><code class="java">public class ArraysMethod01 {public static void main(String[] args) {Integer[] integers = {1, 20, 90};//遍历数组// for(int i = 0; i &lt; integers.length; i++) {// System.out.println(integers[i]);// }//直接使用 Arrays.toString 方法，显示数组// System.out.println(Arrays.toString(integers));////演示 sort 方法的使用Integer arr[] = {1, -1, 7, 0, 89};//进行排序//1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序//2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr//3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序//4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr// (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法//5. 先演示效果，再解释//6. 这里体现了接口编程的方式 , 看看源码，就明白// 源码分析//(1)Arrays.sort(arr, new Comparator()//(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start,// Comparator&lt;? super T&gt; c)()//(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的// 匿名内部类的 compare ()// while (left &lt; right) {// int mid = (left + right) &gt;&gt;&gt; 1;// if (c.compare(pivot, a[mid]) &lt; 0)// right = mid;// else// left = mid + 1;// }//(4) new Comparator() {// @Override// public int compare(Object o1, Object o2) {// Integer i1 = (Integer) o1;// Integer i2 = (Integer) o2;// return i2 - i1;// }// }//(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0// 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用// 将来的底层框架和源码的使用方式，会非常常见//Arrays.sort(arr); // 默认排序方法//定制排序Arrays.sort(arr, new Comparator() {@Overridepublic int compare(Object o1, Object o2) {Integer i1 = (Integer) o1;Integer i2 = (Integer) o2;return i2 - i1;}});System.out.println(&quot;===排序后===&quot;);System.out.println(Arrays.toString(arr));//}}</code></pre><pre><code class="java">public class ArraysSortCustom {public static void main(String[] args) {int[] arr = {1, -1, 8, 0, 20};//bubble01(arr);bubble02(arr, new Comparator() {@Overridepublic int compare(Object o1, Object o2) {int i1 = (Integer) o1;int i2 = (Integer) o2;return i2 - i1;// return i2 - i1;}});System.out.println(&quot;==定制排序后的情况==&quot;);System.out.println(Arrays.toString(arr));}//使用冒泡完成排序public static void bubble01(int[] arr) {int temp = 0;for (int i = 0; i &lt; arr.length - 1; i++) {for (int j = 0; j &lt; arr.length - 1 - i; j++) {//从小到大if (arr[j] &gt; arr[j + 1]) {temp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = temp;}}}}</code></pre><pre><code class="java">//结合冒泡 + 定制public static void bubble02(int[] arr, Comparator c) {int temp = 0;for (int i = 0; i &lt; arr.length - 1; i++) {for (int j = 0; j &lt; arr.length - 1 - i; j++) {//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定if (c.compare(arr[j], arr[j + 1]) &gt; 0) {temp = arr[j];arr[j] = arr[j + 1];arr[j + 1] = temp;}}}}}</code></pre><ul><li><code>`</code>java<br>package com.hspedu.arrays_;<br>import java.util.Arrays;<br>import java.util.List;</li></ul><pre><code>public class ArraysMethod02 {public static void main(String[] args) {Integer[] arr = {1, 2, 90, 123, 567};// binarySearch 通过二分搜索法进行查找，要求必须排好//1. 使用 binarySearch 二叉查找//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch//3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found.int index =Arrays.binarySearch(arr, 567);System.out.println(&quot;index=&quot; + index);//copyOf 数组元素的复制//1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中//2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null//3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException//4. 该方法的底层使用的是 System.arraycopy()Integer[] newArr =Arrays.copyOf(arr, arr.length);System.out.println(&quot;==拷贝执行完毕后==&quot;);System.out.println(Arrays.toString(newArr));//ill 数组元素的填充Integer[] num = new Integer[]{9,3,2};//1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素Arrays.fill(num, 99);System.out.println(&quot;==num 数组填充后==&quot;);System.out.println(Arrays.toString(num));//equals 比较两个数组元素内容是否完全一致Integer[] arr2 = {1, 2, 90, 123};//1. 如果 arr 和 arr2 数组的元素一样，则方法 true;//2. 如果不是完全一样，就返回 falseboolean equals =Arrays.equals(arr, arr2);System.out.println(&quot;equals=&quot; + equals);//asList 将一组值，转换成 list//1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合//2. 返回的 asList 编译类型 List(接口)//3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的// 静态内部类 private static class ArrayList&lt;E&gt; extendsAbstractList&lt;E&gt;// implements RandomAccess, java.io.SerializableList asList =Arrays.asList(2,3,4,5,6,1);System.out.println(&quot;asList=&quot; + asList);System.out.println(&quot;asList 的运行类型&quot; + asList.getClass());}}</code></pre><pre><code>  ### date日期类  Date:精确到毫秒，代表特定的瞬间2) SimpleDateFormat:格式和解析日期的类SimpleDateFormat格式化和解析日期的具体类。它允许进行格式化(日期-&gt;文本)解析(文本-&gt;日期)和规范化.| 3) 应用实例Date java2) </code></pre><p>//1. Calendar 是一个抽象类， 并且构造器是 private<br>//2. 可以通过 getInstance() 来获取实例<br>//3. 提供大量的方法和字段提供给程序员</p><p>//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)<br>//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY<br>Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由<br>System.out.println(“c=” + c);<br>//2.获取日历对象的某个日历字段<br>System.out.println(“年：” + c.get(Calendar.YEAR));<br>// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号<br>System.out.println(“月：” + (c.get(Calendar.MONTH) + 1));<br>System.out.println(“日：” + c.get(Calendar.DAY_OF_MONTH));<br>System.out.println(“小时：” + c.get(Calendar.HOUR));<br>System.out.println(“分钟：” + c.get(Calendar.MINUTE));<br>System.out.println(“秒：” + c.get(Calendar.SECOND));<br>//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示<br>System.out.println(c.get(Calendar.YEAR) + “-“ + (c.get(Calendar.MONTH) + 1) + “-“ +<br>c.get(Calendar.DAY_OF_MONTH) +<br>“ “ + c.get(Calendar.HOUR_OF_DAY) + “:” + c.get(Calendar.MINUTE) + “:” + c.get(Calendar.SECOND) );<br>}<br>}</p><pre><code>#### 第三代日期类</code></pre><p>//1. 使用 now() 返回表示当前日期时间的 对象<br>LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()<br>System.out.println(ldt);<br>//2. 使用 DateTimeFormatter 对象来进行格式化<br>// 创建 DateTimeFormatter 对象<br>DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);<br>String format = dateTimeFormatter.format(ldt);<br>System.out.println(“格式化的日期=” + format);<br>System.out.println(“年=” + ldt.getYear());<br>System.out.println(“月=” + ldt.getMonth());<br>System.out.println(“月=” + ldt.getMonthValue());<br>System.out.println(“日=” + ldt.getDayOfMonth());<br>System.out.println(“时=” + ldt.getHour());<br>System.out.println(“分=” + ldt.getMinute());<br>System.out.println(“秒=” + ldt.getSecond());<br>LocalDate now = LocalDate.now(); //可以获取年月日</p><p>LocalTime now2 = LocalTime.now();//获取到时分秒<br>//提供 plus 和 minus 方法可以对当前时间进行加或者减<br>//看看 890 天后，是什么时候 把 年月日-时分秒<br>LocalDateTime localDateTime = ldt.plusDays(890);<br>System.out.println(“890 天后=” + dateTimeFormatter.format(localDateTime));<br>//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出<br>LocalDateTime localDateTime2 = ldt.minusMinutes(3456);<br>System.out.println(“3456 分钟前 日期=” + dateTimeFormatter.format(localDateTime2));<br>}<br>}</p><pre><code>#### 时间戳</code></pre><p>//1.通过 静态方法 now() 获取表示当前时间戳的对象<br>Instant now = Instant.now();<br>System.out.println(now);<br>//2. 通过 from 可以把 Instant 转成 Date<br>Date date = Date.from(now);</p><p>//3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象<br>Instant instant = date.toInstant();<br>}<br>}</p><pre><code>####  数组</code></pre><p>1)长度开始时必须指定，而且一旦指定，不能正改<br>2)保存的必须为同一类型的元素<br>3)使用数组进行增加/删除元素的示意代码-比较麻烦</p><pre><code>#### 集合</code></pre><p>1)可以动态保存任意多个对象，使用比较方便!<br>2)提供了一系列方便的操作对象的方法: add. remove. set, get等<br>3)使用集合添加，删除新元素的示意代码简洁了</p><pre><code> 集合的框架体系Java 的集合类很多，主要分为两大类，如图 ：[背下来]Collection_.java//1. 集合主要是两组(单列集合 , 双列集合)//2. Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合//3. Map 接口的实现子类 是双列集合，存放的 K-V![image-20220216112130181](C:\Users\张\AppData\Roaming\Typora\typora-user-images\image-20220216112130181.png)![image-20220216112134559](C:\Users\张\AppData\Roaming\Typora\typora-user-images\image-20220216112134559.png)##### Collection 接口和常用方法1) collection实现子类可以存放多个元素，每个元素可以是Object2)有些Collection的实现类， 可以存放重复的元素，有些不可以3)有些Collection的实现类， 有些是有序的(List),有些不是有序(Set)4) Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的collection 接口常用方法,以实现子类 ArrayListList list = newArrayList();// add:添加单个元素remove:删除指定元素contains:查找元素是否存在size:获取元素个数isEmpty:判断是否为空clear:清空addAll:添加多个元素containsAll:查找多个元素是否都存在removeAll：删除多个元素##### Collection 接口遍历元素方式 1-使用 Iterator(迭代器)1) lterator对象称为迭代器，主要用于遍历Collection集合中的元案。2)所有实现了Collection接口的集合类都有一个iterator(方法， 用以返回一个实现了 lterator接口的对象，即可以返回一个迭代器。3) Iterator的结构.[看-张图]4) Iterator仅用于遍历集合，Iterator 本身并不存放对象。</code></pre><p>迭代器的执行原理<br>Iterator iterator = oll.iterator0; //得到<br>个集合的迭代器<br>//hasNext():判断是否还有下一个元素<br>while(iterator.hasNextO{<br>//next作用:1.下移2.将下移以后集合位置<br>.上的元素返回<br>System. out.println(iterator.next0);</p><p>快速生成 while =&gt; itit<br>//显示所有的快捷键的的快捷键 ctrl + j</p><pre><code>#####  Collection 接口遍历对象方式 2-for 循环增强增强for循环， 可以代替iterator迭代器，特点:增强for就是简化版的iterat本质样。只能用于遍历集合或数组。快捷建大寫   I&gt;</code></pre><blockquote><p>基本语法<br>for(元素类型元素名:集合名或数组名) {<br>访问元素<br>案例演示(遍历Book,并使用Debug源码来证明)<br>CollectionForjava<br>for (Object object: col) {<br>System. outprintln(object);<br><code>`</code></p><h3 id="List-接口和常用方法"><a href="#List-接口和常用方法" class="headerlink" title="List 接口和常用方法"></a>List 接口和常用方法</h3></blockquote><pre><code>/1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复 [案例]List list = newArrayList();list.add(&quot;jack&quot;);list.add(&quot;tom&quot;);list.add(&quot;mary&quot;);list.add(&quot;hsp&quot;);/2. List 集合中的每个元素都有其对应的顺序索引，即支持索引// 索引是从 0 开始的System.out.println(list.get(3));</code></pre><pre><code>public static void main(String[] args) {List list = newArrayList();list.add(&quot;张三丰&quot;);list.add(&quot;贾宝玉&quot;);// void add(int index, Object ele):在 index 位置插入 ele 元素//在 index = 1 的位置插入一个对象list.add(1, &quot;啊啊啊&quot;);System.out.println(&quot;list=&quot; + list);// boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来List list2 = newArrayList();list2.add(&quot;jack&quot;);list2.add(&quot;tom&quot;);list.addAll(1, list2);System.out.println(&quot;list=&quot; + list);// Object get(int index):获取指定 index 位置的元素// int indexOf(Object obj):返回 obj 在集合中首次出现的位置System.out.println(list.indexOf(&quot;tom&quot;));//2// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置list.add(&quot;啊啊啊&quot;);System.out.println(&quot;list=&quot; + list);System.out.println(list.lastIndexOf(&quot;啊啊啊&quot;));// Object remove(int index):移除指定 index 位置的元素，并返回此元素list.remove(0);System.out.println(&quot;list=&quot; + list);// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换.list.set(1, &quot;玛丽&quot;);System.out.println(&quot;list=&quot; + list);// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndexList returnlist = list.subList(0, 2);System.out.println(&quot;returnlist=&quot; + returnlist);}}</code></pre>]]></content>
    
    <summary type="html">
    
      String使用教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>练习</title>
    <link href="/2022/03/10/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>/2022/03/10/基础语法/</id>
    <published>2022-03-10T02:02:08.773Z</published>
    <updated>2022-03-10T02:07:20.279Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法递归调用-非常非常重要，比较难"><a href="#方法递归调用-非常非常重要，比较难" class="headerlink" title="方法递归调用(非常非常重要，比较难)"></a>方法递归调用(非常非常重要，比较难)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变<br>得简洁</p><h4 id="递归能解决什么问题"><a href="#递归能解决什么问题" class="headerlink" title="递归能解决什么问题?"></a>递归能解决什么问题?</h4><p>列举两个小案例,来帮助大家理解递归调用机制</p><ol><li><p>打印问题</p></li><li><p>阶乘问题<br>代码</p><pre><code class="java">public class Recursion01 {//编写一个 main 方法public static void main(String[] args) {T t1 = new T();t1.test(4);//输出什么？ n=2 n=3 n=4int res = t1.factorial(5);System.out.println(&quot;5 的阶乘 res =&quot; + res);}}class T {//分析public void test(int n) {if (n &gt; 2) {test(n - 1);}System.out.println(&quot;n=&quot; + n);}</code></pre><p>韩顺平学 循序渐进学 Java 零基础<br>第 220页</p><pre><code class="java">//factorial 阶乘public int factorial(int n) {if (n == 1) {return 1;} else {return factorial(n - 1) * n;}}}</code></pre></li></ol><p>代码</p><pre><code class="java">public class RecursionExercise01 {//编写一个 main 方法public static void main(String[] args) {T t1 = new T();// int n = 7;// int res = t1.fibonacci(n);// if(res != -1) {// System.out.println(&quot;当 n=&quot;+ n +&quot; 对应的斐波那契数=&quot; + res);// }////桃子问题int day = 0;int peachNum = t1.peach(day);if(peachNum != -1) {System.out.println(&quot;第 &quot; + day + &quot;天有&quot; + peachNum + &quot;个桃子&quot;);}    }}class T {/*请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的值是多思路分析1. 当 n = 1 斐波那契数 是 12. 当 n = 2 斐波那契数 是 13. 当 n &gt;= 3 斐波那契数 是前两个数的和4. 这里就是一个递归的思路*/public int fibonacci(int n) {if( n &gt;= 1) {if( n == 1 || n == 2) {return 1;} else {return fibonacci(n-1) + fibonacci(n-2);}} else {System.out.println(&quot;要求输入的 n&gt;=1 的整数&quot;);return -1;}}</code></pre><p>猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！<br>以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时，<br>想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子？<br>思路分析 逆推</p><ol><li><p>day = 10 时 有 1 个桃子</p></li><li><p>day = 9 时 有 (day10 + 1) * 2 = 4</p></li><li><p>day = 8 时 有 (day9 + 1) * 2 = 10</p></li><li><p>规律就是 前一天的桃子 = (后一天的桃子 + 1) *2//就是我们的能力</p></li><li><p>递归<br>*/</p><pre><code class="java">public int peach(int day) {if(day == 10) {//第 10 天，只有 1 个桃return 1;} else if ( day &gt;= 1 &amp;&amp; day &lt;=9 ) {return (peach(day + 1) + 1) * 2;//规则，自己要想} else {System.out.println(&quot;day 在 1-10&quot;);return -1;}}}</code></pre></li></ol><h2 id="数字迷宫找出路"><a href="#数字迷宫找出路" class="headerlink" title="数字迷宫找出路"></a>数字迷宫找出路</h2><pre><code class="java">package com;public class MIGong {    public static void main(String[] args) {//        创建明迷宫//        0表示路径 1表示障碍        int[][] map=new int [18][17];        for (int i = 0; i &lt; 17; i++) {            map[0][i]=1;            map[17][i]=1;        }        for (int i = 0; i &lt; 18; i++) {            map[i][0]=1;            map[i][16]=1;        }        map[3][4]=1;        map[3][5]=1;        map[3][6]=1;        map[3][7]=1;        map[4][4]=1;        map[5][4]=1;        map[2][1]=1;        map[2][2]=1;        map[3][2]=1;        map[5][3]=1;        map[16][15]=3;        Te te = new Te();        te.findWay(map,1,1);        System.out.println(&quot;======招錄情況=======&quot;);//输出地图        System.out.println(&quot;======地图======&quot;);        for (int i = 0; i &lt; map.length; i++) {            for (int j = 0; j &lt; map[i].length; j++) {                System.out.print(map[i][j]+&quot; &quot;);            }            System.out.println();        }    }}class Te {    public boolean findWay(int[][] map,int i,int j){//        int a[][]=map[1][1];        if (map[15][14]==2){//説明找到路            return true;        }else {            if (map[i][j]==0){                map[i][j]=2;                if (findWay(map,i+1,j)){                    return true;                }else if (findWay(map,i,j+1)){                    return true;                }else if (findWay(map, i-1, j)){                    return true;                }else if (findWay(map, i, j-1)){                    return true;                }else {                    map[i][j]=3;                    return false;                }            }            return false;        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      基础算法
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Nacos安装</title>
    <link href="/2022/03/10/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <id>/2022/03/10/Nacos安装指南/</id>
    <published>2022-03-10T01:29:35.424Z</published>
    <updated>2022-03-10T01:58:43.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>如图：<br><img src="source/_posts/assets/image-20210402161102887.png" alt><br><img src="source/_posts/assets/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="assets/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="assets/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="assets/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="assets/image-20210402162251093.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="assets/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><pre><code>startup.cmd -m standalone</code></pre></li></ul><p>执行后的效果如图：</p><p><img src="assets/image-20210402162526774.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos即可：" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="assets/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="assets/image-20210402162709515.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="assets/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><pre><code class="sh">tar -xvf jdk-8u144-linux-x64.tar.gz</code></pre><p>然后重命名为java</p><p>配置环境变量：</p><pre><code class="sh">export JAVA_HOME=/usr/local/javaexport PATH=$PATH:$JAVA_HOME/bin</code></pre><p>设置环境变量：</p><pre><code class="sh">source /etc/profile</code></pre><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="assets/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="assets/image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="assets/image-20210402163715580.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><pre><code class="sh">tar -xvf nacos-server-1.4.1.tar.gz</code></pre><p>然后删除安装包：</p><pre><code class="sh">rm -rf nacos-server-1.4.1.tar.gz</code></pre><p>目录中最终样式：</p><p><img src="assets/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="assets/image-20210402164414827.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><pre><code class="sh">sh startup.sh -m standalone</code></pre><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>客户端：</p><pre><code class="xml">&lt;!-- nacos客户端依赖包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      Nacos安装教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker介绍及使用</title>
    <link href="/2022/03/10/1.1.%E4%BB%80%E4%B9%88%E6%98%AFDocker/"/>
    <id>/2022/03/10/1.1.什么是Docker/</id>
    <published>2022-03-10T01:27:18.470Z</published>
    <updated>2022-03-10T01:28:24.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p>对比来看：</p><p><img src="E:\baiduyunpan\springcloud\学习资料\day03-Docker\讲义\assets\image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。</p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令</p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a>:</p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p>3）通过命令：docker images 查看拉取到的镜像</p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><pre><code class="sh">docker save --help</code></pre><p>命令格式：</p><pre><code class="shell">docker save -o [保存的目标文件名称] [镜像名称]</code></pre><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><pre><code class="sh">docker save -o nginx.tar nginx:latest</code></pre><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><pre><code class="sh">docker rmi nginx:latest</code></pre><p>然后运行命令，加载本地文件：</p><pre><code class="sh">docker load -i nginx.tar</code></pre>]]></content>
    
    <summary type="html">
    
      docker使用教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安装Docker</title>
    <link href="/2022/03/09/%E5%AE%89%E8%A3%85Docker/"/>
    <id>/2022/03/09/安装Docker/</id>
    <published>2022-03-09T12:58:01.864Z</published>
    <updated>2022-03-10T01:28:20.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><pre><code>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine \                  docker-ce</code></pre><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><pre><code class="sh">sudo yum install -y yum-utils \           device-mapper-persistent-data \           lvm2 --skip-broken</code></pre><p>然后更新本地镜像源：</p><pre><code class="shell"># 设置docker镜像源yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposed -i &#39;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repoyum makecache fast</code></pre><p>然后输入命令：</p><pre><code class="shell">yum install -y docker-ce</code></pre><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><pre><code class="sh"># 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld</code></pre><p>通过命令启动docker：</p><pre><code class="sh">systemctl start docker  # 启动docker服务systemctl stop docker  # 停止docker服务systemctl restart docker  # 重启docker服务</code></pre><p>然后输入命令，可以查看docker版本：</p><pre><code>docker -v</code></pre><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><pre><code class="shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &quot;registry-mirrors&quot;:[&quot;https://n0dwemtq.mirror.aliyuncs.com&quot;] }EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><pre><code class="sh"># 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="assets/image-20210417133020614.png" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><pre><code class="sh"># 修改权限chmod +x /usr/local/bin/docker-compose</code></pre><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><pre><code class="sh"># 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><p>如果这里出现错误，需要修改自己的hosts文件：</p><pre><code class="sh">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</code></pre><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry" target="_blank" rel="noopener">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><pre><code class="sh">docker run -d \    --restart=always \    --name registry    \    -p 5000:5000 \    -v registry-data:/var/lib/registry \    registry</code></pre><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://YourIp:5000/v2/_catalog" target="_blank" rel="noopener">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><pre><code class="yaml">version: &#39;3.0&#39;services:  registry:    image: registry    volumes:      - ./registry-data:/var/lib/registry  ui:    image: joxit/docker-registry-ui:static    ports:      - 8080:80    environment:      - REGISTRY_TITLE=传智教育私有仓库      - REGISTRY_URL=http://registry:5000    depends_on:      - registry</code></pre><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><pre><code class="sh"># 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker</code></pre>]]></content>
    
    <summary type="html">
    
      docker安装教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="笔记" scheme="/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch</title>
    <link href="/2021/12/12/%E5%AE%89%E8%A3%85elasticsearch/"/>
    <id>/2021/12/12/安装elasticsearch/</id>
    <published>2021-12-12T14:16:01.000Z</published>
    <updated>2022-03-10T02:00:28.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h1><h1 id="1-部署单点es"><a href="#1-部署单点es" class="headerlink" title="1.部署单点es"></a>1.部署单点es</h1><h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><pre><code class="sh">docker network create es-net</code></pre><h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>大家将其上传到虚拟机中，然后运行命令加载即可：</p><pre><code class="sh"># 导入数据docker load -i es.tar</code></pre><p>同理还有<code>kibana</code>的tar包也需要这样做。</p><h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p><pre><code class="sh">docker run -d \    --name es \    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \    -e &quot;discovery.type=single-node&quot; \    -v es-data:/usr/share/elasticsearch/data \    -v es-plugins:/usr/share/elasticsearch/plugins \    --privileged \    --network es-net \    -p 9200:9200 \    -p 9300:9300 \elasticsearch:7.12.1</code></pre><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://192.168.150.101:9200" target="_blank" rel="noopener">http://192.168.150.101:9200</a> 即可看到elasticsearch的响应结果</p><h1 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p><h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana</p><pre><code class="sh">docker run -d \--name kibana \-e ELASTICSEARCH_HOSTS=http://es:9200 \--network=es-net \-p 5601:5601  \kibana:7.12.1</code></pre><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><pre><code class="sh">docker logs -f kibana</code></pre><p>查看运行日志，查看是否成功。</p><p>在浏览器输入地址访问：<a href="http://192.168.150.101:5601，即可看到结果" target="_blank" rel="noopener">http://192.168.150.101:5601，即可看到结果</a></p><h2 id="2-2-DevTools"><a href="#2-2-DevTools" class="headerlink" title="2.2.DevTools"></a>2.2.DevTools</h2><p>kibana中提供了一个DevTools界面：</p><p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p><h1 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h1><p>(<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a>)</p><p>(<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a>)</p><h2 id="3-1-在线安装ik插件（较慢）"><a href="#3-1-在线安装ik插件（较慢）" class="headerlink" title="3.1.在线安装ik插件（较慢）"></a>3.1.在线安装ik插件（较慢）</h2><pre><code class="shell"># 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch</code></pre><h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><pre><code class="sh">docker volume inspect es-plugins</code></pre><p>显示结果：</p><pre><code class="json">[    {        &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;,        &quot;Name&quot;: &quot;es-plugins&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    }]</code></pre><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data</code>这个目录中。</p><h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>需要资料中的ik分词器解压缩，重命名为ik</p><h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data</code>：</p><h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><pre><code class="shell"># 4、重启容器docker restart es</code></pre><pre><code class="sh"># 查看es日志docker logs -f es</code></pre><h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p>IK分词器包含两种模式：</p><ul><li><p><code>ik_smart</code>：最少切分</p></li><li><p><code>ik_max_word</code>：最细切分</p></li></ul><pre><code class="json">GET /_analyze{  &quot;analyzer&quot;: &quot;ik_max_word&quot;,  &quot;text&quot;: &quot;程序员学习java&quot;}</code></pre><h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><p>词汇不断的更新，IK分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录：</p><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt;        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;        &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt;</code></pre><p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><p>4）重启elasticsearch </p><pre><code class="sh">docker restart es# 查看 日志docker logs -f elasticsearch</code></pre><p>日志中已经成功加载ext.dic配置文件</p><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p><h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt;        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;        &lt;!--用户可以在这里配置自己的扩展字典--&gt;        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;         &lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;        &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;&lt;/properties&gt;</code></pre><p>3）在 stopword.dic 添加停用词</p><p>4）重启elasticsearch </p><pre><code class="sh"># 重启服务docker restart elasticsearchdocker restart kibana# 查看 日志docker logs -f elasticsearch</code></pre><p>日志中已经成功加载stopword.dic配置文件</p><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p><h1 id="4-部署es集群"><a href="#4-部署es集群" class="headerlink" title="4.部署es集群"></a>4.部署es集群</h1><p>部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有<strong>4G</strong>的内存空间</p><p>首先写一个docker-compose文件，内容如下：</p><pre><code class="sh">version: &#39;2.2&#39;services:  es01:    image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1    container_name: es01    environment:      - node.name=es01      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es02,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data01:/usr/share/elasticsearch/data    ports:      - 9200:9200    networks:      - elastic  es02:    image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1    container_name: es02    environment:      - node.name=es02      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data02:/usr/share/elasticsearch/data    networks:      - elastic  es03:    image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1    container_name: es03    environment:      - node.name=es03      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es02      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data03:/usr/share/elasticsearch/data    networks:      - elasticvolumes:  data01:    driver: local  data02:    driver: local  data03:    driver: localnetworks:  elastic:    driver: bridge</code></pre><p>Run <code>docker-compose</code> to bring up the cluster:</p><pre><code class="sh">docker-compose up</code></pre>]]></content>
    
    <summary type="html">
    
      elasticsearch安装
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="/2021/12/12/Test/"/>
    <id>/2021/12/12/Test/</id>
    <published>2021-12-12T14:16:01.000Z</published>
    <updated>2022-03-10T02:03:20.897Z</updated>
    
    <content type="html"><![CDATA[<!-- 添加图片 --><!-- ![](https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg) -->   <!-- 添加链接 --><p><a href="https://github.com/" target="_blank" rel="noopener">前往github</a></p><!-- 添加标题 --><!-- ## 交流群 --><!-- 添加 --><!--     ## 主题特性<!-- 添加选项 --> <!-- - 首页大屏视频 - 首页随机封面 - 图片懒加载 - valine评论 - fancy-box相册 - pjax支持，音乐不间断 - aplayer音乐播放器 --> <p>yml</p><pre><code class="yml"></code></pre><p>java</p><pre><code class="java">public static void mian(String[] args){}</code></pre>]]></content>
    
    <summary type="html">
    
      主题使用教程
    
    </summary>
    
    
      <category term="web" scheme="/tags/web/"/>
    
      <category term="悦读" scheme="/tags/%E6%82%A6%E8%AF%BB/"/>
    
  </entry>
  
</feed>
