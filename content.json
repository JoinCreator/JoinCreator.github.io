{"meta":{"title":"zhang","subtitle":null,"description":"罗马","author":"ZHANG","url":""},"pages":[{"title":"donate","date":"2021-12-20T15:13:05.000Z","updated":"2022-03-08T13:43:59.461Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"感谢"},{"title":"about","date":"2021-12-12T14:14:36.000Z","updated":"2022-03-11T06:22:31.046Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[SHUAI] 与&nbsp; Mashiro&nbsp; （ friends ） 对话中...","keywords":"关于"},{"title":"comment","date":"2021-12-20T15:13:48.000Z","updated":"2022-03-10T07:08:52.189Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"诗和远方！ 以铜为镜，可以正衣冠；以古为镜，可以知兴替；以人为镜，可以明得失。 《旧唐书·魏征列传》","keywords":"留言板"},{"title":"rss","date":"2021-12-20T15:09:03.000Z","updated":"2022-03-10T01:16:47.246Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2022-01-04T14:53:25.000Z","updated":"2022-03-08T06:43:25.155Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"","keywords":"hello"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-03-10T06:05:21.924Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2021-12-12T14:14:16.000Z","updated":"2022-03-10T01:11:08.261Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2021-12-19T15:11:06.000Z","updated":"2022-03-10T01:23:57.368Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友情链接"},{"title":"comment","date":"2021-12-20T15:13:48.000Z","updated":"2022-03-11T06:31:43.951Z","comments":true,"path":"Webhtml/index.html","permalink":"/Webhtml/index.html","excerpt":"","text":"欢迎评论&nbsp;&nbsp;&nbsp;留言 表情 图片 视频 话题 文章 发布 王永康 我是王牛逼 2022年3月12日 删除","keywords":"留言板"}],"posts":[{"title":"","slug":"a","date":"2022-03-10T07:23:56.805Z","updated":"2022-03-10T07:28:58.569Z","comments":true,"path":"2022/03/10/a/","link":"","permalink":"/2022/03/10/a/","excerpt":"","text":"评论区留言 .div1,div{ width: 1350px; margin:0 auto; } 昵称： 留言： //通过id属性查找标签节点 var user=document.getElementById('user'); var lang=document.getElementById('lang'); //通过id属性查找提交评价按钮并绑定点击事件 document.getElementById('btn').onclick=function(){ //在html代码中创建一个div盒子 var cont=document.createElement('div'); //将获取到的数据，放到一创建好的盒子中 cont.innerHTML=''+user.value+':'+lang.value+''; //将创建好的div盒子及及内容显示在页面中 document.getElementById('div1').appendChild(cont); user.value=''; lang.value=''; }","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"abc","date":"2022-03-10T07:21:31.174Z","updated":"2022-03-10T07:23:30.818Z","comments":true,"path":"2022/03/10/abc/","link":"","permalink":"/2022/03/10/abc/","excerpt":"","text":"HTML5实现留言和回复的页面-H5教程-PHP中文网var is_mobi=navigator.userAgent.toLowerCase().match(/(ipod|ipad|iphone|android|coolpad|mmp|smartphone|midp|wap|xoom|symbian|j2me|blackberry|wince)/i)!=null;if(is_mobi){window.location.href=\"https://m.php.cn/article/402476.html\";}var _czc = _czc || [];_czc.push([\"_setAccount\", \"1280886301\"]);.layui-badge-dots{margin-right: 15px;width: 5px;height: 5px;background: #bbb!important;position: relative;display: inline-block;font-size: 12px;text-align: center;background-color: #FF5722;color: #fff;padding: 0;border-radius: 50%;}.relevant{color: #666;}.relevant:hover{color: #bbb}.php-article .detail-content-wrap th{background-color: #e9ecef;}.php-article .detail-content-wrap table{margin-bottom:15px;}.content ul li {list-style: unset;margin-left: 25px;font-size:16px;margin:8px 0 8px 30px;color:#3d464d;}.page ul li{list-style:none;font-size: 14px;margin-left: 0;}.content ul li p{padding:0!important;}.profile-info .layui-icon-auz{padding-left:10px;}.php-article .content h2{padding-left:10px;font-weight:600;}{\"@context\": \"https://zhanzhang.baidu.com/contexts/cambrian.jsonld\",\"@id\": \"https://www.php.cn/html5-tutorial-402476.html\",\"title\": \"HTML5实现留言和回复的页面\",\"description\": \"这篇文章主要介绍了用HTML5如何实现留言和回复样式,需要的朋友可以参考下\",\"images\": [\"https://img.php.cn/upload/article/000/000/009/5b1b8d78e5ba8969.jpg\"],\"pubDate\": \"2018-06-09T16:19:17\",\"upDate\": \"2018-06-09T16:19:17\"}首页视频教程 视频课程直播课程学习路径 入门教程独孤九贱玉女心经天龙八部趣味闯关PHP培训资源下载 工具下载在线工具手册下载电子课件js特效网站源码网站素材类库下载技术文章 头条前端开发后端开发数据库php框架每日编程社区 问答博客编程词典APP下载登录注册&#xe615;首页 >web前端 >H5教程 > 正文HTML5实现留言和回复的页面&#xe609;原创&#xe60e;2018-06-09 16:19:17&#xe63a;0&#xe756;4519这篇文章主要介绍了用HTML5如何实现留言和回复样式,需要的朋友可以参考下具体就不做详细讲解了，直接上代码：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;http://www.webkfa.com/&quot; /&gt; &lt;title&gt;web开发-webkfa.com&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *{ margin:0;padding:0; -webkit-touch-callout: none; /* prevent callout to copy image, etc when tap to hold */ -webkit-text-size-adjust: none; /* prevent webkit from resizing text to fit */ -webkit-tap-highlight-color: rgba(210,210,210,0.35); /* make transparent link selection, adjust last value opacity 0 to 1.0 */ -webkit-user-select: none; /* prevent copy paste, to allow, change &#39;none&#39; to &#39;text&#39; */ } body{font-family:&quot;微软雅黑&quot;;font-size:12px;} ul,li{list-style:none;} .ylcon{width:100%;min-width:320px;} .tit{height:26px;line-height:26px;padding:0px 15px;position:relative;font-size:15px;color:#aaa;border-bottom:1px solid rgba(0, 0, 0, 0.15);} .story{border-bottom:1px dashed #cecece;padding:0 15px 3px;position:relative;} .story_t{font-size:1.2em;color:rgba(0,0,0,1);padding-top:5px;padding-bottom:2px;} .story_m{color:rgba(110,110,110,1);line-height:21px;word-break:break-all;word-wrap:break-word;overflow:hidden;font-size:1.2em;padding:2px 0;} .story_time{color:rgba(154,154,154,1);padding:2px 0;} .story_hf{background:rgb(245,245,245);font-size:1.2em;border:1px solid rgba(204,204,204,0.2);border-radius:2px;color:rgba(110,110,110,1);padding:4px;margin-bottom:5px;} .opbtn{position:absolute;top: 0;right: 0;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;ylcon&quot;&gt; &lt;p class=&quot;tit&quot;&gt; 所有留言 &lt;/p&gt; &lt;p id=&quot;messpId&quot;&gt; &lt;p class=&quot;story&quot;&gt; &lt;p class=&quot;opbtn&quot;&gt;&lt;/p&gt; &lt;p class=&quot;story_t&quot;&gt;怜星&lt;/p&gt; &lt;p class=&quot;story_time&quot;&gt;2015/07/12 20:48&lt;/p&gt; &lt;p class=&quot;story_m&quot;&gt;我想问最近最火的tfboys呢他们的八卦呢我想问最近最火的tfboys呢,他们的八卦呢我想问最近最火的tfboys呢？！他们的八卦呢？！&lt;/p&gt; &lt;p class=&quot;story_hf&quot;&gt;@剑花烟雨:的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契&lt;/p&gt; &lt;/p&gt; &lt;p class=&quot;story&quot;&gt; &lt;p class=&quot;opbtn&quot;&gt;&lt;/p&gt; &lt;p class=&quot;story_t&quot;&gt;怜星&lt;/p&gt; &lt;p class=&quot;story_time&quot;&gt;2015/07/12 20:48&lt;/p&gt; &lt;p class=&quot;story_m&quot;&gt;我想问最近最火的tfboys呢他们的八卦呢我想问最近最火的tfboys呢,他们的八卦呢我想问最近最火的tfboys呢？！他们的八卦呢？！&lt;/p&gt; &lt;p class=&quot;story_hf&quot;&gt;@剑花烟雨:的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契&lt;/p&gt; &lt;/p&gt; &lt;p class=&quot;story&quot;&gt; &lt;p class=&quot;opbtn&quot;&gt;&lt;/p&gt; &lt;p class=&quot;story_t&quot;&gt;怜星&lt;/p&gt; &lt;p class=&quot;story_time&quot;&gt;2015/07/12 20:48&lt;/p&gt; &lt;p class=&quot;story_m&quot;&gt;我想问最近最火的tfboys呢他们的八卦呢我想问最近最火的tfboys呢,他们的八卦呢我想问最近最火的tfboys呢？！他们的八卦呢？！&lt;/p&gt; &lt;p class=&quot;story_hf&quot;&gt;@剑花烟雨:的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契的是相对无言眼波如流的默契&lt;/p&gt; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;以上就是本文的全部内容，希望对大家的学习有所帮助，更多相关内容请关注PHP中文网！相关推荐：html5生成柱状图(条形图)效果的实例代码如何利用HTML5实现分享到微信好友朋友圈QQ好友QQ空间微博二维码的功能以上就是HTML5实现留言和回复的页面的详细内容，更多请关注php中文网其它相关文章！&#xe63a;微信&#xe641;分享声明：本文内容由网友自发贡献，版权归原作者所有，本站不承担相应法律责任。如您发现有涉嫌抄袭侵权的内容，请联系admin@php.cn核实处理。相关标签：html5页面样式 HTML5上一篇：如何在微信端html5页面调用分享接口下一篇：HTML5实现使用按钮控制背景音乐开关的方法相关文章相关视频html5离线存储有哪些深入解析asp.net中mvc4自定义404页面（...在今天，利用 HTML5 开发和发布大型跨平台网游...避免常见的六种HTML5错误用法 (5-6)HTML5实现留言和回复的页面HTML5浏览器支持HTML5新元素HTML5内联SVGHTML5 MathMLHTML5 拖放网友评论文明上网理性发言，请遵守 新闻评论服务协议我要评论立即提交专题推荐独孤九贱-php全栈开发教程全栈 170W+主讲：Peter-Zhu 轻松幽默、简短易学，非常适合PHP学习入门玉女心经-web前端开发教程入门 80W+主讲：灭绝师太 由浅入深、明快简洁，非常适合前端学习入门天龙八部-实战开发教程实战 120W+主讲：西门大官人 思路清晰、严谨规范，适合有一定web编程基础学习作者信息不言认证0级讲师最近文章查找的快捷键是ctrl键加上什么键229278剪切快捷键ctrl加什么？374480it是什么职业？44076发布技术文章最新文章热门排行html5的doctype声明是什么html5编辑器有哪些html5离线存储有哪些html5新增了什么h5新增标签audio与video的使用html5 app开发框架有哪些你值得了解的WEB前端跨域解决方案（代码详解）手把手教你使用给站点开启https和http2（附代码）h5是什么app是什么意思什么是前端和后端不懂代码怎么制作h5页面？H5页面制作平台推荐Google AMP 是什么鬼？HTML5开发实例-3D全景(ThreeJs全景Demo) 详解（图）HTML5如何实现视频直播功能如何用HTML5在页面中插入可自动播放的视频推荐视频教程javascript初级视频教程jquery 基础视频教程视频教程分类php视频教程html视频教程css视频教程JS视频教程jQuery视频教程mysql视频教程Linux视频教程Python视频教程article_status = 153291;网站首页 PHP视频PHP实战PHP代码PHP手册词条手记编程词典php培训php中文网：公益在线php培训，帮助PHP学习者快速成长！Copyright 2014-2021 https://www.php.cn/ All Rights Reserved | 苏ICP备2020058653号-1关于我们免责申明赞助与捐赠广告合作&nbsp;&nbsp; .layui-fixbar{bottom:200px;}var _hmt = _hmt || [];(function(){var hm = document.createElement(\"script\");hm.src=\"//hm.baidu.com/hm.js?aaf8dba0861f46190106021371583c62\";var s=document.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(hm, s);})();(function(){var bp = document.createElement('script');var curProtocol = window.location.protocol.split(':')[0];if(curProtocol === 'https'){bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';}else{bp.src = 'http://push.zhanzhang.baidu.com/push.js';};var s = document.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(bp, s);})();var topadshow = $.cookie('phpcndatatopadshows');if(!topadshow&&1==2){$('.topimages').show();var topobj = $('.topimages').find('.time');var topobj_day = $('.topimages .time').find('.day');var topobj_hours = $('.topimages .time').find('.hours');var topobj_minutes = $('.topimages .time').find('.minutes');var topobj_second = $('.topimages .time').find('.second');var topday = parseInt(topobj_day.html());var tophours = parseInt(topobj_hours.html());var topminutes = parseInt(topobj_minutes.html());var topsecond = parseInt(topobj_second.html());setInterval(function(){if(topsecond > 0){topsecond = topsecond-1;}else{if(topminutes > 0){topminutes = topminutes-1;topsecond = 59;}else{if(tophours > 0){tophours = tophours-1;topminutes = 59;topsecond = 59;}else{if(topday > 0){topday = topday -1;tophours = 23;topminutes = 59;topsecond = 59;}else{topobj.html(\"活动已结束\");}}}}topobj_second.html(topsecond);topobj_minutes.html(topminutes);topobj_hours.html(tophours);topobj_day.html(topday);},1000);}$('.topimages .layui-icon-close').click(function(){$.cookie('phpcndatatopadshows',1,{expires:7});$('.topimages').hide();});$('.content_article_viewer_show').viewer();","categories":[],"tags":[],"keywords":[]},{"title":"String","slug":"String","date":"2022-03-10T02:02:08.797Z","updated":"2022-03-10T02:03:32.550Z","comments":true,"path":"2022/03/10/String/","link":"","permalink":"/2022/03/10/String/","excerpt":"","text":"String类：一.常用方法 package com.test03; /** * Settings-Editor-File and Code Templates */ public class StringTest { public static void main(String[] args) { //1. equals 前面已经讲过了. 比较内容是否相同，区分大小写 String str1 = &quot;hello&quot;; String str2 = &quot;Hello&quot;; System.out.println(str1.equals(str2));// // 2.equalsIgnoreCase 忽略大小写的判断内容是否相等 String username = &quot;johN&quot;; if (&quot;john&quot;.equalsIgnoreCase(username)) { System.out.println(&quot;Success!&quot;); } else { System.out.println(&quot;Failure!&quot;); } // 3.length 获取字符的个数，字符串的长度 System.out.println(&quot;韩顺平&quot;.length()); // 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1 String s1 = &quot;wer@terwe@g&quot;; int index = s1.indexOf(&#39;@&#39;); System.out.println(index);// 3 System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0 // 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1 s1 = &quot;wer@terwe@g@&quot;; index = s1.lastIndexOf(&#39;@&#39;); System.out.println(index);//11 System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4 // 6.substring 截取指定范围的子串 String name = &quot;hello,张三&quot;; //下面 name.substring(6) 从索引 6 开始截取后面所有的内容 System.out.println(name.substring(6));//截取后面的字符 //name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置 System.out.println(name.substring(2,5));//llo } } package com.test03; /** * Settings-Editor-File and Code Templates */ public class StringTest02 { public static void main(String[] args) { // 1.toUpperCase 转换成大写 String s = &quot;heLLo&quot;; System.out.println(s.toUpperCase());//HELLO // 2.toLowerCase System.out.println(s.toLowerCase());//hello // 3.concat 拼接字符串 String s1 = &quot;宝玉&quot;; s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;); System.out.println(s1);//宝玉林黛玉薛宝钗 together // 4.replace 替换字符串中的字符 s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;; //在 s1 中，将 所有的 林黛玉 替换成薛宝钗 // s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响 String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;); System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉 System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉 // 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\\\等 String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;; // 1. 以 , 为标准对 poem 进行分割 , 返回一个数组 // 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \\ String[] split = poem.split(&quot;,&quot;); poem = &quot;E:\\\\aaa\\\\bbb&quot;; split = poem.split(&quot;\\\\\\\\&quot;); System.out.println(&quot;==分割后内容===&quot;); for (int i = 0; i &lt; split.length; i++) { System.out.println(split[i]); } // 6.toCharArray 转换成字符数组 s = &quot;happy&quot;; char[] chs = s.toCharArray(); for (int i = 0; i &lt; chs.length; i++) { System.out.println(chs[i]); } // 7.compareTo 比较两个字符串的大小，如果前者大， // 则返回正数，后者大，则返回负数，如果相等，返回 0 // (1) 如果长度相同，并且每个字符也相同，就返回 0 // (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小 // 就返回 if (c1 != c2) { // return c1 - c2; // } // (3) 如果前面的部分都相同，就返回 str1.len - str2.len String a = &quot;jcck&quot;;// len = 3 String b = &quot;jack&quot;;// len = 4 System.out.println(a.compareTo(b)); // 返回值是 &#39;c&#39; - &#39;a&#39; = 2 的值 // 8.format 格式字符串 /* 占位符有: * %s 字符串 %c 字符 %d 整型 %.2f 浮点型 * */ String name = &quot;john&quot;; int age = 10; double score = 56.857; char gender = &#39;男&#39;; //将所有的信息都拼接在一个字符串. String info = &quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！ &quot;; System.out.println(info); //1. %s , %d , %.2f %c 称为占位符 //2. 这些占位符由后面变量来替换 //3. %s 表示后面由 字符串来替换 //4. %d 是整数来替换 //5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理 //6. %c 使用 char 类型来替换 String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;; String info2 = String.format(formatStr, name, age, score, gender); System.out.println(&quot;info2=&quot; + info2); } } StringBuffer 类：public class StringBuffer01 { public static void main(String[] args) { //1. StringBuffer 的直接父类 是 AbstractStringBuilder //2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 //3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final // 该 value 数组存放 字符串内容，引出存放在堆中的 //4. StringBuffer 是一个 final 类，不能被继承 //5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除) // 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;); } } String VS StringBuffer1) String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址， 效率较低//private final char value[];2) StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高//char[] value; /这个放在堆 String 和 StringBuffer 相互转换 `javapublic class StringAndStringBuffer {public static void main(String[] args) {//看 String——&gt;StringBuffer String str = “hello tom”;//方式 1 使用构造器//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响StringBuffer stringBuffer = new StringBuffer(str);//方式 2 使用的是 append 方法StringBuffer stringBuffer1 = new StringBuffer();stringBuffer1 = stringBuffer1.append(str);//看看 StringBuffer -&gt;StringStringBuffer stringBuffer3 = new StringBuffer(“韩顺平教育”);//方式 1 使用 StringBuffer 提供的 toString 方法String s = stringBuffer3.toString();//方式 2: 使用构造器来搞定String s1 = new String(stringBuffer3);}}13.5.4 StringBuffer 类常见方法package com.hspedu.stringbuffer_; public class StringBufferMethod { public static void main(String[] args) { StringBuffer s = new StringBuffer(&quot;hello&quot;); //增 s.append(&#39;,&#39;);// &quot;hello,&quot; s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot; s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot; System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot; //删 /* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符 解读: 删除 11~14 的字符 [11, 14)*/s.delete(11, 14);System.out.println(s);//“hello,张三丰赵敏 true10.5”//改//，使用 周芷若 替换 索引 9-11 的字符 [9,11)s.replace(9, 11, “周芷若”);System.out.println(s);//“hello,张三丰周芷若 true10.5”//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1int indexOf = s.indexOf(“张三丰”);System.out.println(indexOf);//6//插 //，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移s.insert(9, “赵敏”);System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”//长度System.out.println(s.length());//22System.out.println(s);}} ` StringBuffer 类常见方法`java public class StringBufferMethod {public static void main(String[] args) {StringBuffer s = new StringBuffer(“hello”);//增s.append(‘,’);// “hello,”s.append(“张三丰”);//“hello,张三丰”s.append(“赵敏”).append(100).append(true).append(10.5);//“hello,张三丰赵敏 100true10.5”System.out.println(s);//“hello,张三丰赵敏 100true10.5”//删/* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符 解读: 删除 11~14 的字符 [11, 14)*/s.delete(11, 14);System.out.println(s);//“hello,张三丰赵敏 true10.5”//改//，使用 周芷若 替换 索引 9-11 的字符 [9,11)s.replace(9, 11, “周芷若”);System.out.println(s);//“hello,张三丰周芷若 true10.5”//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1int indexOf = s.indexOf(“张三丰”);System.out.println(indexOf);//6//插 //，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移s.insert(9, “赵敏”);System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”//长度System.out.println(s.length());//22System.out.println(s);}}` StringBuffer 类测试题 1 StringBufferExercise01.javapublic class StringBufferExercise01 { public static void main(String[] args) { String str = null;// ok StringBuffer sb = new StringBuffer(); //ok sb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNull System.out.println(sb.length());//4 System.out.println(sb);//null 韩顺平学 循序渐进学 Java 零基础 第 561页 //下面的构造器，会抛出 NullpointerException StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16); System.out.println(sb1); } } public class StringBufferExercise02 { public static void main(String[] args) { /* 输入商品名称和商品价格，要求打印效果示例, 使用前面学习的方法完成： 商品名 商品价格 手机 123,564.59 //比如 价格 3,456,789.88 要求：价格的小数点前面每三位用逗号隔开, 在输出。 思路分析 1. 定义一个 Scanner 对象，接收用户输入的 价格(String) 2. 希望使用到 StringBuffer 的 insert ，需要将 String 转成 StringBuffer 3. 然后使用相关方法进行字符串的处理 代码实现 */ //new Scanner(System.in) String price = &quot;8123564.59&quot;; StringBuffer sb = new StringBuffer(price); //先完成一个最简单的实现 123,564.59 //找到小数点的索引，然后在该位置的前 3 位，插入,即可 // int i = sb.lastIndexOf(&quot;.&quot;); // sb = sb.insert(i - 3, &quot;,&quot;); //上面的两步需要做一个循环处理,才是正确的 for (int i = sb.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0; i -= 3) { sb = sb.insert(i, &quot;,&quot;); } System.out.println(sb);//8,123,564.59 } } StringBuilder01 java1)一个可变的字符序列。此类提供一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类因为在大多数实现中，它比StringBuffer要快[后面测]。2)在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。 public class StringBuffer01 { public static void main(String[] args) { //1. StringBuffer 的直接父类 是 AbstractStringBuilder //2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 //3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final // 该 value 数组存放 字符串内容，引出存放在堆中的 //4. StringBuffer 是一个 final 类，不能被继承 //5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除) // 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;); } } public class StringBuilder01 { public static void main(String[] args) { //1. StringBuilder 继承 AbstractStringBuilder 类 //2. 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件) //3. StringBuilder 是 final 类, 不能被继承 //4. StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value; // 因此，字符序列是堆中 //5. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用 // StringBuilder StringBuilder stringBuilder = new StringBuilder(); } } String、StringBuffer 和 StringBuilder 的比较 1) StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样2) String: 不可变字符序列，效率低,但是复用率高。3) StringBuffer: 可变字符序列、效率较高(增删)、线程安全，看源码4) StringBuilder: 可变字符序列、效率最高、线程不安全5) String使用注意说明:string s= “a”; //创建了一个字符串s += “b”; //实际上原来的” a”字符串对象已经丢弃了，现在又产生了一个字符I串s+”b” (也就是”ab”)。 如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=&gt;结论:如果我们对String做大量修改，不要使用String String、StringBuffer 和 StringBuilder 的选择使用的原则， 结论:1.如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder2.如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder3.如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等StringBuilder的方法使用和StringBuffer一样 Math 类Math 类常见方法public class MathMethod { public static void main(String[] args) { //看看 Math 常用的方法(静态方法) //1.abs 绝对值 int abs = Math.abs(-9); System.out.println(abs);//9 //2.pow 求幂 double pow = Math.pow(2, 4);//2 的 4 次方 System.out.println(pow);//16 //3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double); double ceil = Math.ceil(3.9); System.out.println(ceil);//4.0 //4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double) double floor = Math.floor(4.001); System.out.println(floor);//4.0 //5.round 四舍五入 Math.floor(该参数+0.5) long round = Math.round(5.51); System.out.println(round);//6 //6.sqrt 求开方 double sqrt = Math.sqrt(9.0); System.out.println(sqrt);//3.0 //7.random 求随机数 // random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数 // 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7 // 即返回一个数 x 2 &lt;= x &lt;= 7 // Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a // (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) ) // (2) 使用具体的数给小伙伴介绍 a = 2 b = 7 // (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6) // Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数 // 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数 // (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7 // (3) 公式就是 (int)(a + Math.random() * (b-a +1) ) for(int i = 0; i &lt; 100; i++) { System.out.println((int)(2 + Math.random() * (7 - 2 + 1))); } //max , min 返回最大值和最小值 int min = Math.min(1, 9); int max = Math.max(45, 90); System.out.println(&quot;min=&quot; + min); System.out.println(&quot;max=&quot; + max); } } Arrays 类Arrays 类常见方法应用public class ArraysMethod01 { public static void main(String[] args) { Integer[] integers = {1, 20, 90}; //遍历数组 // for(int i = 0; i &lt; integers.length; i++) { // System.out.println(integers[i]); // } //直接使用 Arrays.toString 方法，显示数组 // System.out.println(Arrays.toString(integers));// //演示 sort 方法的使用 Integer arr[] = {1, -1, 7, 0, 89}; //进行排序 //1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序 //2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr //3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序 //4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr // (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法 //5. 先演示效果，再解释 //6. 这里体现了接口编程的方式 , 看看源码，就明白 // 源码分析 //(1)Arrays.sort(arr, new Comparator() //(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, // Comparator&lt;? super T&gt; c)() //(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的 // 匿名内部类的 compare () // while (left &lt; right) { // int mid = (left + right) &gt;&gt;&gt; 1; // if (c.compare(pivot, a[mid]) &lt; 0) // right = mid; // else // left = mid + 1; // } //(4) new Comparator() { // @Override // public int compare(Object o1, Object o2) { // Integer i1 = (Integer) o1; // Integer i2 = (Integer) o2; // return i2 - i1; // } // } //(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0 // 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用 // 将来的底层框架和源码的使用方式，会非常常见 //Arrays.sort(arr); // 默认排序方法 //定制排序 Arrays.sort(arr, new Comparator() { @Override public int compare(Object o1, Object o2) { Integer i1 = (Integer) o1; Integer i2 = (Integer) o2; return i2 - i1; } }); System.out.println(&quot;===排序后===&quot;); System.out.println(Arrays.toString(arr));// } } public class ArraysSortCustom { public static void main(String[] args) { int[] arr = {1, -1, 8, 0, 20}; //bubble01(arr); bubble02(arr, new Comparator() { @Override public int compare(Object o1, Object o2) { int i1 = (Integer) o1; int i2 = (Integer) o2; return i2 - i1;// return i2 - i1; } }); System.out.println(&quot;==定制排序后的情况==&quot;); System.out.println(Arrays.toString(arr)); } //使用冒泡完成排序 public static void bubble01(int[] arr) { int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { //从小到大 if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //结合冒泡 + 定制 public static void bubble02(int[] arr, Comparator c) { int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { //数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定 if (c.compare(arr[j], arr[j + 1]) &gt; 0) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } } `javapackage com.hspedu.arrays_;import java.util.Arrays;import java.util.List; public class ArraysMethod02 { public static void main(String[] args) { Integer[] arr = {1, 2, 90, 123, 567}; // binarySearch 通过二分搜索法进行查找，要求必须排好 //1. 使用 binarySearch 二叉查找 //2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch //3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found. int index =Arrays.binarySearch(arr, 567); System.out.println(&quot;index=&quot; + index); //copyOf 数组元素的复制 //1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中 //2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null //3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException //4. 该方法的底层使用的是 System.arraycopy() Integer[] newArr =Arrays.copyOf(arr, arr.length); System.out.println(&quot;==拷贝执行完毕后==&quot;); System.out.println(Arrays.toString(newArr)); //ill 数组元素的填充 Integer[] num = new Integer[]{9,3,2}; //1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素 Arrays.fill(num, 99); System.out.println(&quot;==num 数组填充后==&quot;); System.out.println(Arrays.toString(num)); //equals 比较两个数组元素内容是否完全一致 Integer[] arr2 = {1, 2, 90, 123}; //1. 如果 arr 和 arr2 数组的元素一样，则方法 true; //2. 如果不是完全一样，就返回 false boolean equals =Arrays.equals(arr, arr2); System.out.println(&quot;equals=&quot; + equals); //asList 将一组值，转换成 list //1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合 //2. 返回的 asList 编译类型 List(接口) //3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的 // 静态内部类 private static class ArrayList&lt;E&gt; extendsAbstractList&lt;E&gt; // implements RandomAccess, java.io.Serializable List asList =Arrays.asList(2,3,4,5,6,1); System.out.println(&quot;asList=&quot; + asList); System.out.println(&quot;asList 的运行类型&quot; + asList.getClass()); } } ### date日期类 Date:精确到毫秒，代表特定的瞬间 2) SimpleDateFormat:格式和解析日期的类 SimpleDateFormat格式化和解析日期的具 体类。它允许进行格式化(日期-&gt;文本) 解析(文本-&gt;日期)和规范化. | 3) 应用实例Date java 2) //1. Calendar 是一个抽象类， 并且构造器是 private//2. 可以通过 getInstance() 来获取实例//3. 提供大量的方法和字段提供给程序员 //4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAYCalendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由System.out.println(“c=” + c);//2.获取日历对象的某个日历字段System.out.println(“年：” + c.get(Calendar.YEAR));// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号System.out.println(“月：” + (c.get(Calendar.MONTH) + 1));System.out.println(“日：” + c.get(Calendar.DAY_OF_MONTH));System.out.println(“小时：” + c.get(Calendar.HOUR));System.out.println(“分钟：” + c.get(Calendar.MINUTE));System.out.println(“秒：” + c.get(Calendar.SECOND));//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示System.out.println(c.get(Calendar.YEAR) + “-“ + (c.get(Calendar.MONTH) + 1) + “-“ +c.get(Calendar.DAY_OF_MONTH) +“ “ + c.get(Calendar.HOUR_OF_DAY) + “:” + c.get(Calendar.MINUTE) + “:” + c.get(Calendar.SECOND) );}} #### 第三代日期类 //1. 使用 now() 返回表示当前日期时间的 对象LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()System.out.println(ldt);//2. 使用 DateTimeFormatter 对象来进行格式化// 创建 DateTimeFormatter 对象DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);String format = dateTimeFormatter.format(ldt);System.out.println(“格式化的日期=” + format);System.out.println(“年=” + ldt.getYear());System.out.println(“月=” + ldt.getMonth());System.out.println(“月=” + ldt.getMonthValue());System.out.println(“日=” + ldt.getDayOfMonth());System.out.println(“时=” + ldt.getHour());System.out.println(“分=” + ldt.getMinute());System.out.println(“秒=” + ldt.getSecond());LocalDate now = LocalDate.now(); //可以获取年月日 LocalTime now2 = LocalTime.now();//获取到时分秒//提供 plus 和 minus 方法可以对当前时间进行加或者减//看看 890 天后，是什么时候 把 年月日-时分秒LocalDateTime localDateTime = ldt.plusDays(890);System.out.println(“890 天后=” + dateTimeFormatter.format(localDateTime));//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出LocalDateTime localDateTime2 = ldt.minusMinutes(3456);System.out.println(“3456 分钟前 日期=” + dateTimeFormatter.format(localDateTime2));}} #### 时间戳 //1.通过 静态方法 now() 获取表示当前时间戳的对象Instant now = Instant.now();System.out.println(now);//2. 通过 from 可以把 Instant 转成 DateDate date = Date.from(now); //3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象Instant instant = date.toInstant();}} #### 数组 1)长度开始时必须指定，而且一旦指定，不能正改2)保存的必须为同一类型的元素3)使用数组进行增加/删除元素的示意代码-比较麻烦 #### 集合 1)可以动态保存任意多个对象，使用比较方便!2)提供了一系列方便的操作对象的方法: add. remove. set, get等3)使用集合添加，删除新元素的示意代码简洁了 集合的框架体系 Java 的集合类很多，主要分为两大类，如图 ：[背下来] Collection_.java //1. 集合主要是两组(单列集合 , 双列集合) //2. Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合 //3. Map 接口的实现子类 是双列集合，存放的 K-V ![image-20220216112130181](C:\\Users\\张\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220216112130181.png) ![image-20220216112134559](C:\\Users\\张\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220216112134559.png) ##### Collection 接口和常用方法 1) collection实现子类可以存放多个元素，每个元素可以是Object 2)有些Collection的实现类， 可以存放重复的元素，有些不可以 3)有些Collection的实现类， 有些是有序的(List),有些不是有序(Set) 4) Collection接口没有直接的实现子类，是通过它的子接口Set和List来 实现的 collection 接口常用方法,以实现子类 ArrayList List list = newArrayList(); // add:添加单个元素 remove:删除指定元素 contains:查找元素是否存在 size:获取元素个数 isEmpty:判断是否为空 clear:清空 addAll:添加多个元素 containsAll:查找多个元素是否都存在 removeAll：删除多个元素 ##### Collection 接口遍历元素方式 1-使用 Iterator(迭代器) 1) lterator对象称为迭代器，主要用于遍历Collection集合中的元案。 2)所有实现了Collection接口的集合类都有一个iterator(方法， 用以返回 一个实现了 lterator接口的对象，即可以返回一个迭代器。 3) Iterator的结构.[看-张图] 4) Iterator仅用于遍历集合，Iterator 本身并不存放对象。 迭代器的执行原理Iterator iterator = oll.iterator0; //得到个集合的迭代器//hasNext():判断是否还有下一个元素while(iterator.hasNextO{//next作用:1.下移2.将下移以后集合位置.上的元素返回System. out.println(iterator.next0); 快速生成 while =&gt; itit//显示所有的快捷键的的快捷键 ctrl + j ##### Collection 接口遍历对象方式 2-for 循环增强 增强for循环， 可以代替iterator迭代器，特点:增强for就是简化版的iterat 本质样。只能用于遍历集合或数组。 快捷建大寫 I &gt; 基本语法for(元素类型元素名:集合名或数组名) {访问元素案例演示(遍历Book,并使用Debug源码来证明)CollectionForjavafor (Object object: col) {System. outprintln(object);` List 接口和常用方法 /1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复 [案例] List list = newArrayList(); list.add(&quot;jack&quot;); list.add(&quot;tom&quot;); list.add(&quot;mary&quot;); list.add(&quot;hsp&quot;); /2. List 集合中的每个元素都有其对应的顺序索引，即支持索引 // 索引是从 0 开始的 System.out.println(list.get(3)); public static void main(String[] args) { List list = newArrayList(); list.add(&quot;张三丰&quot;); list.add(&quot;贾宝玉&quot;); // void add(int index, Object ele):在 index 位置插入 ele 元素 //在 index = 1 的位置插入一个对象 list.add(1, &quot;啊啊啊&quot;); System.out.println(&quot;list=&quot; + list); // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来 List list2 = newArrayList(); list2.add(&quot;jack&quot;); list2.add(&quot;tom&quot;); list.addAll(1, list2); System.out.println(&quot;list=&quot; + list); // Object get(int index):获取指定 index 位置的元素 // int indexOf(Object obj):返回 obj 在集合中首次出现的位置 System.out.println(list.indexOf(&quot;tom&quot;));//2 // int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置 list.add(&quot;啊啊啊&quot;); System.out.println(&quot;list=&quot; + list); System.out.println(list.lastIndexOf(&quot;啊啊啊&quot;)); // Object remove(int index):移除指定 index 位置的元素，并返回此元素 list.remove(0); System.out.println(&quot;list=&quot; + list); // Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;); System.out.println(&quot;list=&quot; + list); // List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合 // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex List returnlist = list.subList(0, 2); System.out.println(&quot;returnlist=&quot; + returnlist); } }","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]},{"title":"练习","slug":"基础语法","date":"2022-03-10T02:02:08.773Z","updated":"2022-03-10T02:07:20.279Z","comments":true,"path":"2022/03/10/基础语法/","link":"","permalink":"/2022/03/10/基础语法/","excerpt":"","text":"方法递归调用(非常非常重要，比较难)基本介绍简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变得简洁 递归能解决什么问题?列举两个小案例,来帮助大家理解递归调用机制 打印问题 阶乘问题代码 public class Recursion01 { //编写一个 main 方法 public static void main(String[] args) { T t1 = new T(); t1.test(4);//输出什么？ n=2 n=3 n=4 int res = t1.factorial(5); System.out.println(&quot;5 的阶乘 res =&quot; + res); } } class T { //分析 public void test(int n) { if (n &gt; 2) { test(n - 1); } System.out.println(&quot;n=&quot; + n); } 韩顺平学 循序渐进学 Java 零基础第 220页 //factorial 阶乘 public int factorial(int n) { if (n == 1) { return 1; } else { return factorial(n - 1) * n; } } } 代码 public class RecursionExercise01 { //编写一个 main 方法 public static void main(String[] args) { T t1 = new T(); // int n = 7; // int res = t1.fibonacci(n); // if(res != -1) { // System.out.println(&quot;当 n=&quot;+ n +&quot; 对应的斐波那契数=&quot; + res); // } // //桃子问题 int day = 0; int peachNum = t1.peach(day); if(peachNum != -1) { System.out.println(&quot;第 &quot; + day + &quot;天有&quot; + peachNum + &quot;个桃子&quot;); } } } class T { /* 请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的值是多 思路分析 1. 当 n = 1 斐波那契数 是 1 2. 当 n = 2 斐波那契数 是 1 3. 当 n &gt;= 3 斐波那契数 是前两个数的和 4. 这里就是一个递归的思路 */ public int fibonacci(int n) { if( n &gt;= 1) { if( n == 1 || n == 2) { return 1; } else { return fibonacci(n-1) + fibonacci(n-2); } } else { System.out.println(&quot;要求输入的 n&gt;=1 的整数&quot;); return -1; } } 猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时，想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子？思路分析 逆推 day = 10 时 有 1 个桃子 day = 9 时 有 (day10 + 1) * 2 = 4 day = 8 时 有 (day9 + 1) * 2 = 10 规律就是 前一天的桃子 = (后一天的桃子 + 1) *2//就是我们的能力 递归*/ public int peach(int day) { if(day == 10) {//第 10 天，只有 1 个桃 return 1; } else if ( day &gt;= 1 &amp;&amp; day &lt;=9 ) { return (peach(day + 1) + 1) * 2;//规则，自己要想 } else { System.out.println(&quot;day 在 1-10&quot;); return -1; } } } 数字迷宫找出路package com; public class MIGong { public static void main(String[] args) { // 创建明迷宫 // 0表示路径 1表示障碍 int[][] map=new int [18][17]; for (int i = 0; i &lt; 17; i++) { map[0][i]=1; map[17][i]=1; } for (int i = 0; i &lt; 18; i++) { map[i][0]=1; map[i][16]=1; } map[3][4]=1; map[3][5]=1; map[3][6]=1; map[3][7]=1; map[4][4]=1; map[5][4]=1; map[2][1]=1; map[2][2]=1; map[3][2]=1; map[5][3]=1; map[16][15]=3; Te te = new Te(); te.findWay(map,1,1); System.out.println(&quot;======招錄情況=======&quot;); //输出地图 System.out.println(&quot;======地图======&quot;); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j]+&quot; &quot;); } System.out.println(); } } } class Te { public boolean findWay(int[][] map,int i,int j){ // int a[][]=map[1][1]; if (map[15][14]==2){//説明找到路 return true; }else { if (map[i][j]==0){ map[i][j]=2; if (findWay(map,i+1,j)){ return true; }else if (findWay(map,i,j+1)){ return true; }else if (findWay(map, i-1, j)){ return true; }else if (findWay(map, i, j-1)){ return true; }else { map[i][j]=3; return false; } } return false; } } }","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]},{"title":"Nacos安装","slug":"Nacos安装指南","date":"2022-03-10T01:29:35.424Z","updated":"2022-03-10T01:58:43.367Z","comments":true,"path":"2022/03/10/Nacos安装指南/","link":"","permalink":"/2022/03/10/Nacos安装指南/","excerpt":"","text":"Nacos安装指南1.Windows安装开发阶段采用单机安装即可。 1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码： GitHub主页：https://github.com/alibaba/nacos GitHub的Release下载页：https://github.com/alibaba/nacos/releases 如图： 本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包： windows版本使用nacos-server-1.4.1.zip包即可。 1.2.解压将这个包解压到任意非中文目录下，如图： 目录说明： bin：启动脚本 conf：配置文件 1.3.端口配置Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。 如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口： 修改其中的内容： 1.4.启动启动非常简单，进入bin目录，结构如下： 然后执行命令即可： windows命令： startup.cmd -m standalone 执行后的效果如图： 1.5.访问在浏览器输入地址：http://127.0.0.1:8848/nacos即可： 默认的账号和密码都是nacos，进入后： 2.Linux安装Linux或者Mac安装方式与Windows类似。 2.1.安装JDKNacos依赖于JDK运行，索引Linux上也需要安装JDK才行。 上传jdk安装包： 上传到某个目录，例如：/usr/local/ 然后解压缩： tar -xvf jdk-8u144-linux-x64.tar.gz 然后重命名为java 配置环境变量： export JAVA_HOME=/usr/local/java export PATH=$PATH:$JAVA_HOME/bin 设置环境变量： source /etc/profile 2.2.上传安装包如图： 也可以直接使用课前资料中的tar.gz： 上传到Linux服务器的某个目录，例如/usr/local/src目录下： 2.3.解压命令解压缩安装包： tar -xvf nacos-server-1.4.1.tar.gz 然后删除安装包： rm -rf nacos-server-1.4.1.tar.gz 目录中最终样式： 目录内部： 2.4.端口配置与windows中类似 2.5.启动在nacos/bin目录中，输入命令启动Nacos： sh startup.sh -m standalone 3.Nacos的依赖父工程： &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 客户端： &lt;!-- nacos客户端依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"Docker介绍及使用","slug":"1.1.什么是Docker","date":"2022-03-10T01:27:18.470Z","updated":"2022-03-10T01:28:24.578Z","comments":true,"path":"2022/03/10/1.1.什么是Docker/","link":"","permalink":"/2022/03/10/1.1.什么是Docker/","excerpt":"","text":"1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图： 对比来看： 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 1.3.Docker架构1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry 1.4.安装Docker企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。 2.Docker的基本操作2.1.镜像操作2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 2.1.2.镜像命令常见的镜像操作命令 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： docker save --help 命令格式： docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： docker save -o nginx.tar nginx:latest 3）使用docker load加载镜像 先删除本地的nginx镜像： docker rmi nginx:latest 然后运行命令，加载本地文件： docker load -i nginx.tar","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"安装Docker","slug":"安装Docker","date":"2022-03-09T12:58:01.864Z","updated":"2022-03-10T01:28:20.740Z","comments":true,"path":"2022/03/09/安装Docker/","link":"","permalink":"/2022/03/09/安装Docker/","excerpt":"","text":"0.安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。 Docker CE 分为 stable test 和 nightly 三个更新频道。 官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。 1.CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。 1.1.卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.2.安装docker首先需要大家虚拟机联网，安装yum工具 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： # 设置docker镜像源 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i &#39;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repo yum makecache fast 然后输入命令： yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 1.3.启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ # 关闭 systemctl stop firewalld # 禁止开机启动防火墙 systemctl disable firewalld 通过命令启动docker： systemctl start docker # 启动docker服务 systemctl stop docker # 停止docker服务 systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： docker -v 1.4.配置镜像加速docker官方镜像仓库网速较差，我们需要设置国内镜像服务： 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &quot;registry-mirrors&quot;:[&quot;https://n0dwemtq.mirror.aliyuncs.com&quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： # 安装 curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件： 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： # 修改权限 chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：# 补全命令 curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： docker run -d \\ --restart=always \\ --name registry \\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： version: &#39;3.0&#39; services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： # 打开要修改的文件 vi /etc/docker/daemon.json # 添加内容： &quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;] # 重加载 systemctl daemon-reload # 重启docker systemctl restart docker","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"elasticsearch","slug":"安装elasticsearch","date":"2021-12-12T14:16:01.000Z","updated":"2022-03-10T02:00:28.316Z","comments":true,"path":"2021/12/12/安装elasticsearch/","link":"","permalink":"/2021/12/12/安装elasticsearch/","excerpt":"","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络： docker network create es-net 1.2.加载镜像大家将其上传到虚拟机中，然后运行命令加载即可： # 导入数据 docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： docker logs -f kibana 查看运行日志，查看是否成功。 在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器(https://github.com/medcl/elasticsearch-analysis-ik) (https://github.com/medcl/elasticsearch-analysis-ik) 3.1.在线安装ik插件（较慢）# 进入容器内部 docker exec -it elasticsearch /bin/bash # 在线下载并安装 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip #退出 exit #重启容器 docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: docker volume inspect es-plugins 显示结果： [ { &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; } ] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data这个目录中。 2）解压缩分词器安装包需要资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data： 4）重启容器# 4、重启容器 docker restart es # 查看es日志 docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 GET /_analyze { &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;程序员学习java&quot; } 3.3 扩展词词典词汇不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; &lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 4）重启elasticsearch docker restart es # 查看 日志 docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典1）IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; &lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt; &lt;/properties&gt; 3）在 stopword.dic 添加停用词 4）重启elasticsearch # 重启服务 docker restart elasticsearch docker restart kibana # 查看 日志 docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有4G的内存空间 首先写一个docker-compose文件，内容如下： version: &#39;2.2&#39; services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data02:/usr/share/elasticsearch/data networks: - elastic es03: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data03:/usr/share/elasticsearch/data networks: - elastic volumes: data01: driver: local data02: driver: local data03: driver: local networks: elastic: driver: bridge Run docker-compose to bring up the cluster: docker-compose up","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]},{"title":"Test","slug":"Test","date":"2021-12-12T14:16:01.000Z","updated":"2022-03-10T02:03:20.897Z","comments":true,"path":"2021/12/12/Test/","link":"","permalink":"/2021/12/12/Test/","excerpt":"","text":"前往github yml java public static void mian(String[] args){ }","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]}]}