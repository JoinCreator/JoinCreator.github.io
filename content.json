{"meta":{"title":"zhang","subtitle":null,"description":"罗马","author":"ZHANG","url":""},"pages":[{"title":"comment","date":"2021-12-20T15:13:48.000Z","updated":"2022-03-11T06:31:43.951Z","comments":true,"path":"Webhtml/index.html","permalink":"/Webhtml/index.html","excerpt":"","text":"欢迎评论&nbsp;&nbsp;&nbsp;留言 表情 图片 视频 话题 文章 发布 王永康 我是王牛逼 2022年3月12日 删除","keywords":"留言板"},{"title":"donate","date":"2021-12-20T15:13:05.000Z","updated":"2022-03-08T13:43:59.461Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"感谢"},{"title":"about","date":"2021-12-12T14:14:36.000Z","updated":"2022-03-12T07:59:43.093Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[SHUAI]","keywords":"关于"},{"title":"comment","date":"2021-12-20T15:13:48.000Z","updated":"2022-04-03T01:45:10.154Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"诗和远方！ 以铜为镜，可以正衣冠；以古为镜，可以知兴替；以人为镜，可以明得失。 《旧唐书·魏征列传》 (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); 为正常使用来必力评论功能请激活JavaScript","keywords":"留言板"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-03-10T06:05:21.924Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2021-12-19T15:11:06.000Z","updated":"2022-03-10T01:23:57.368Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友情链接"},{"title":"tags","date":"2021-12-12T14:14:16.000Z","updated":"2022-03-10T01:11:08.261Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2021-12-20T15:09:03.000Z","updated":"2022-03-10T01:16:47.246Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2022-01-04T14:53:25.000Z","updated":"2022-03-08T06:43:25.155Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"","keywords":"hello"}],"posts":[{"title":"java基础","slug":"java基础","date":"2022-04-03T00:44:22.314Z","updated":"2022-04-03T00:49:16.023Z","comments":true,"path":"2022/04/03/java基础/","link":"","permalink":"/2022/04/03/java基础/","excerpt":"","text":"0.安装Docker一、java特点1、java语言是面向对象的（oop） 2、java语言是健壮性的，Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证 3、 Java 语言是 跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台] 4、 Java 语言是解释型的[了解] 解释性语言：javascript,PHP, java 编译性语言: c / c++ 区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c++ JDK 基本介绍JDK 的全称(Java Development Kit Java 开发工具包) JDK = JRE + java 的开发工具 [java, javac,javadoc,javap 等] JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK 中. 2) JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。 JRE 基本介绍 1) JRE(Java Runtime Environment Java 运行环境) JRE = JVM + Java 的核心类库[类] 2) 包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。 JDK、JRE 和 JVM 的包含关系 1) JDK = JRE + 开发工具集（例如 Javac,java 编译工具等) 2) JRE = JVM + Java SE 标准类库（java 核心类库） 3) 如果只想运行开发好的 .class 文件 只需要 JRE 安装jdk配置环境变量 java程序运行流程 Java 开发注意事项和细节1. Java源文件以 java为扩展名。源文件的基本组成部分是类(class) ， 如本类中的Hello 类。 2. Java应用程序的执行入口是main(方法。它有固定的书写格式: public static void main(String[ args) {...} 3. Java语言严格区分大小写. 4. Java方法由一条条语句构成，每个语句以“,&quot; 结束。 5.大括号都是成对出现的，缺一不可。 [习惯， 先写{}再写代码] 6.一个源文件中最多只能有一个public类。其它类的个数不限。 7.如果源文件包含一个public类， 则文件名必须按该类名命名! 8.一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public 类，这样入口方法就是非public的main方法 Java 转义字符Java 常用的转义字符在控制台，输入 tab 键，可以实现命令补全 &quot;\\“代表转义符 \\t ：一个制表位，实现对齐的功能 \\n ：换行符 \\\\ \\：表示一个\\ \\\\ &quot; :一个&quot; \\\\ &#39;：一个&#39; \\r :一个回车 注释(comment)用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良 好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。 [举例] 1) 单行注释 // 2) 多行注释 /* */ 3) 文档注释 /** */ 常用的 dos 命令1) 查看当前目录是有什么内容 dir dir dir d:\\abc2\\test200 2) 切换到其他盘下：盘符号 cd : change directory 案例演示：切换到 c 盘 cd /D c: 3) 切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录 案例演示： cd d:\\abc2\\test200 cd ..\\..\\abc2\\test200 4) 切换到上一级： 案例演示： cd .. 5) 切换到根目录：cd \\ 案例演示：cd \\ 6) 查看指定的目录下所有的子级目录 tree 7) 清屏 cls [苍老师] 8) 退出 DOS exit 9) 说明: (md[创建目录],rd[删除目录],copy[拷贝文件],del[删除文件],echo[输入内容到文件],type,move[剪切]) =&gt; Linux, 二、变量概念变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过 门牌号我们可以找到房间，而通过变量名可以访问到变量(值)。 变量使用的基本步骤 变量必须先声明在使用 1) 声明变量 int a; 2) 赋值 a = 60; // 把 60 赋给 a 使用 System.out.println(a); //也可以一步到位[int a = 60; 通常我们是一步完成] 变量使用注意事项1.变量表示内存中的一个存储区域[不同的变量，类型不同，占用的空间大小不同， 比如: int 4个字节，double 就是8个字节] 2.该区域有自己的名称[安量名]和类型[数据类型] 3.变量必须先声明，后使用，即有顺序 4.该区域的数据/值可以在同一类型范围内不断变化 5.变量在同一个作用域内不能重名 6.变量=变量名+值+数据类型。变量三要素 三、数据类型每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。 基本数据类型整数型：基本数据类型： byte[1], 范围 （-128 ~ 127） short[2], 范围 -2^15 ~ 2^15-1 （-32768-32767） int[4], 范围 -2^31 ~ 2^31-1 (-2147483648-2147483647) long[8], 范围 -2^63 ~ 2^63-1 ## 引用数据类型： 类：closs 接口：interface 数组：[...] 浮点型： float[4],double[8] 1) 关于浮点数在机器中存放形式的简单说明,浮点数=符号位+指数位+尾数位 2) 尾数部分可能丢失，造成精度损失(小数都是近似值)。 通常情况下使用double类型 及缴纳更多更高 1.与整数类型类似，Java 浮点类型也有固定的范围和字段长度，不受具体OS的 影响。[float 4个字节double是8个字节] 2. Java 的浮点型常量(具体值)默认为double型，声明float型常量， 须后加&#39;f&#39; 或&#39;F&#39; 3.浮点型常量有两种表示形式 十进制数形式:如: 5.12 512.0f .512 (必须有小数点) 科学计数法形式:如: 5.12e2 [5.12*10的2次方] 5.12E-2 [5.12/10的2次方] 4.通常情况下，应该使用double型，因为它比float型更精确。[举例说明] double num9 = 2.1234567851; float num10 = 2.1234567851F; 5.浮点数使用陷阱:2.7和8.1 / 3比较 double num7 = 2.7; double num8=8.1/ 3; if Math.abs(num7 - num8) &lt; .00001)[ System out. orintln(&quot;相等一): 字符型: char[2] 字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 Stringan[1] //在 java 中，char 的本质是一个整数，在默认输出时，是 unicode 码对应的字符 //要输出对应的数字，可以(int)字符 //char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. 1.字符常量是用单引号(”)括起来的单个字符。 例如: charc1 = &#39;a&#39;; charc2 = &#39;中&#39;; charc3 = &#39;9&#39;; 2. Java中还允许使用转义字符T来将其后的字符转变为特殊字符型常量。 例如: charc3 = In&#39; ; // &quot;\\n&#39;表示换行符 3.在java中， char的本质是个整数，在输出时，是unicode码对应的字符。 http://tool.chinaz.com/ Tools/Unicode.aspx 4.可以直接给char一个整数，然后输出时，会按照对应 的unicode字符输出[97-》a] 3. char类型是可以进行运算的， 相当于一个整数， 因为它 都对应有Unicode码. 布尔类型：boolean[1] 1.布尔类型也叫boolean类型，booolean类型数据只允许取值true和false,无 null 2. boolean类型占1个字节。 3. boolean 类型适于逻辑运算，一般用于程序流程控制: 1 if条件控制语句; V while循环控制语句; V do-while循环控制语句; V for循环控制语句 基本数据类型转换自动类型转换：V介绍当java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换1数据类型按精度(容量)大小排序为(背会) char --&gt; int --&gt; long--&gt; float--&gt; double byte--&gt; short--&gt; int--&gt; long--&gt; float--&gt; double 自动类型转换注意和细节: 1.有多种类型的混合数据运算时，系统首先自动将所有数据转换成最大容量的那种数据类型，然后进行计算。 2.当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换。 3.（byte，short）和char之间不会相互自动转换 4.byte，short,char 他们三者可以计算，在计算时首先转换为int类型。 5.boolean 不参与转换 6.自动提升原则：表达式结果的类型自动提升为操作数中最大的类型 强制类型转换：介绍自动类型转换的逆过程， 将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成精度降低或溢出,格外要注意 int i= (int)1.9; System.out.println(i); int j=100; byte b=(byte)j; System.out.println(b); 强制类型转换细节: 1.当进行数据的大小从大&gt; 小，就需要使用到强制转换 2.强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级 //intx = (int)10*3.5+6*1.5; inty = (int)(10*3.5+6*1.5); System.out.println(y); 3. char类型可以保存int的常量值，但不能保存int的变量值，需要强转 charc1 = 100; //ok int m = 100; //ok char c2 = m; //错误 char c3=(char)m //ok System.out. rintnt(3//100对应的字符 4. byte和short, char类型在进行运算时，当做int类型处理。 基本数据类型转String在程序开发中，我们经常需要将基本数据类型转成String类型。或者将String类 型转成基本数据类型。 1、基本数据类型转换为String类型 语法：将基本数据类型+” “即可 2、String类型转换为基本数据类型 使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型 语法：通过剧本类型的包装类调用parsexxx方法即可 // 怎么把字符串转成字符 char -&gt; 指 含义是指 把字符串的第一个字符得到 //解读 s5.charAt(0) 得到 s5 字符串的第一个字符 &#39;1&#39; 注意事项: 1) 在将 String 类型转成 基本数据类型时， ，比如 我们可以把 &quot;123&quot; , 转成一 个整数，但是不能把 &quot;hello&quot; 转成一个整数 2) 如果格式不正确，就会 抛出异常，程序就会终止 四、运算符运算符介绍运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。 细节说明: 1.对于除号&quot;/&quot;,它的整数除和小数除是有区别的:整数之间做除法时，只保留整 数部分而舍弃小数部分。例如: intx= 10/3 ,结果是3 2.当对一个数取模时，可以等价a%b=a-a/b*b，这样我们可以看到取模的-一 个本质运算。 3.当自增当做一个独立语言使用时，不管是++i;还是i++;都是一样的，等价 4.当自增当做一个表达式使用时j = ++i等价[?] 5.当自增当做一个表达式使用时j = i++等价[2] // % 取模 ,取余 // 在 % 的本质 看一个公式!!!! a % b = a - a / b * b // -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1 // 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1 // -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1 前++：++i 先自增后赋值 后++：i++先赋值后自增 面试题1 int i= 1;//i-&gt; 1 i=i+ +; //规则使用临时变量: (1) temp=i;(2) i=i+ 1:(3)i=temp: System.out.println(); // 1 问:结果是多少?为什么? 面试题2 int i=1; i=+ +i; //规则使用临时变量: (1) i=i+ 1;(2) temp=i;(3)i= temp; System.out.println(i); //2 练习： 1) 假如还有 59 天放假，问：合 xx 个星期零 xx 天 2) 定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度。 [234.5]//编写一个 main 方法 public static void main(String[] args) { //1.需求: //假如还有 59 天放假，问：合 xx 个星期零 xx 天 //2.思路分析 //(1) 使用 int 变量 days 保存 天数 //(2) 一个星期是 7 天 星期数 weeks： days / 7 零 xx 天 leftDays days % 7 //(3) 输出 //3.走代码 int days = 25911; int weeks = days / 7; int leftDays = days % 7; System.out.println(days + &quot;天 合&quot; + weeks + &quot;星期零&quot; + leftDays + &quot;天&quot;); //1.需求 //定义一个变量保存华氏温度，华氏温度转换摄氏温度的公式为 //：5/9*(华氏温度-100),请求出华氏温度对应的摄氏温度 // //2 思路分析 //(1) 先定义一个 double huaShi 变量保存 华氏温度 //(2) 根据给出的公式，进行计算即可 5/9*(华氏温度-100) // 考虑数学公式和 java 语言的特性 //(3) 将得到的结果保存到 double sheShi //3 走代码 double huaShi = 1234.6; double sheShi = 5.0 / 9 * (huaShi - 100); System.out.println(&quot;华氏温度&quot; + huaShi + &quot; 对应的摄氏温度=&quot; + sheShi); } 赋值运算符赋值运算符就是将某个运算后的值，赋给指定的变量。 赋值运算符的分类 基本赋值运算符 = int a = 10; 复合赋值运算符 += ，-= ，*= ， /= ，%= 等 , 重点讲解一个 += ，其它的使用是一个道理 a += b; [等价 a = a + b; ] a -= b; [等价 a = a - b; ] assign ： 分配，指派，賦值 赋值运算符特点 1) 运算顺序从右往左 int num = a + b + c; 2) 赋值运算符的左边 只能是变量,右边 可以是变量、表达式、常量值 int num = 20; int num2= 78 * 34 - 10; int num3 = a; 3) 复合赋值运算符等价于下面的效果 比如：a+=3;等价于 a=a+3; 其他类推 4) 复合赋值运算符会进行类型转换。 byte b = 2; b+=3; b++; 关系运算符 [比较运算符] 1) 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false 2) 关系表达式 经常用在 if 结构的条件中或循环结构的条件中 细节说明 1) 关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 2) 关系运算符组成的表达式，我们称为关系表达式。 a &gt; b 3) 比较运算符&quot;==&quot;不能误写成&quot;=&quot; 逻辑运算符用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值。 1) 短路与 &amp;&amp; ， 短路或 ||，取反 ! 2) 逻辑与 &amp;，逻辑或 |，^ 逻辑异或 说明逻辑运算规则： 1) a&amp;b : &amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false 2) a&amp;&amp;b : &amp;&amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 3) a|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 4) a||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 5) !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 6) a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false &amp;&amp; 和 &amp; 基本规则 名称 语法 特点 短路与&amp;&amp; 条件 1&amp;&amp;条件 2 两个条件都为 true，结果为 true,否则 false 逻辑与&amp; 条件 1&amp;条件 2 两个条件都为 true，结果为 true,否则 false &amp;&amp; 和 &amp; 使用区别 1) &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高 2) &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低 3) 开发中， 我们使用的基本是使用短路与&amp;&amp;, 效率高 || 和 | 基本规则 名称 语法 特点 短路或|| 条件 1||条件 2 两个条件中只要有一个成立，结果为 true,否则为 false |逻辑或 条件 1|条件 2 只要有一个条件成立，结果为 true,否则为 false || 和 | 使用区别 1) ||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高 2) | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低 3) 开发中，我们基本使用 || 取反 基本规则 名称 语法 特点 ! 非（取反） !条件 如果条件本身成立，结果为 false，否则为 true //!和^案例演示 public class InverseOperator { //编写一个 main 方法 public static void main(String[] args) { //! 操作是取反 T-&gt;F , F -&gt; T System.out.println(60 &gt; 20); //T System.out.println(!(60 &gt; 20)); //F //a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false boolean b = (10 &gt; 1) ^ ( 3 &gt; 5); System.out.println(&quot;b=&quot; + b);//T } } ^ 案例演示 a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false ^逻辑异或，System.out.println( (4 &lt; 1) ^ (6 &gt; 3) ); // ? 三元运算符基本语法 条件表达式 ? 表达式 1: 表达式 2; 运算规则： 1. 如果条件表达式为 true，运算后的结果是表达式 1； 2. 如果条件表达式为 false，运算后的结果是表达式 2； 口诀: [一灯大师：一真大师] 使用细节 表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换) 三元运算符可以转成 if--else 语句 int res = a &gt; b ? a++ : --b; if ( a &gt; b) res = a++; else res = --b; //三元运算符细节 public class TernaryOperatorDetail { //编写一个 main 方法 public static void main(String[] args) { //表达式 1 和表达式 2 要为可以赋给接收变量的类型 //(或可以自动转换/或者强制转换) int a = 3; int b = 8; int c = a &gt; b ? (int)1.1 : (int)3.4;//可以的 double d = a &gt; b ? a : b + 3;//可以的，满足 int -&gt; double } } 运算符优先级1) 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。 2) 只有单目运算符、赋值运算符是从右向左运算的。 3) 一览表, 不要背，使用多了，就熟悉了. 标识符的命名规则和 规范 标识符概念： 1. Java对各种变量、方法和类等命名时使用的字符序列称为标识符 2. 凡是自己可以起名字的地方都叫标识符int num1 = 90; , 标识符的命名规则(必须遵守) .由26个英文字母大小写，0-9，或$组成 3. 数字不可以开头。 int 3ab = 1;//错误 4. 不可以使用关键字和保留字，但能包含关键字和保留字。 Java中严格区分大小写，长度无限制。int totalNum = 10; intn = 90; 5. 标识符不能包含空格。intab = 90; 标识符命名规范[更加专业] 1) 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 2) 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 3) 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法] 比如： tankShotGame 4) 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 关键字 关键字的定义和特点 ( 不用背) 定义：被 Java 语言赋予了特殊含义，用做 专门用途的字符串（单词） 特点：关键字中所有字母都为小写 保留字 4.10.1 介绍 Java 保留字：现有 Java 版本 尚未使用，但 以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留 字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const 键盘输入语句 介绍 在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是Scanner mport java.util.Scanner;//表示把 java.util 下的 Scanner 类导入 //2. 创建 Scanner 对象 , new 创建一个对象,体会 // myScanner 就是 Scanner 类的对象 Scanner myScanner = new Scanner(System.in); //当程序执行到 next 方法时，会等待用户输入~~~ String name = myScanner.next(); //接收用户输入字符串 int age = myScanner.nextInt(); //接收用户输入 int double sal = myScanner.nextDouble(); //接收用户输入 double 五、进制表示方式 进制介绍 对于整数，有四种表示方式： 二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 十进制：0-9 ，满 10 进 1。 八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 或 0X 开头表示。此处的 A-F 不区分大小写。 进制转换 第一组： 1) 二进制转十进制 规则:从最低位(右边)开始，将每个位上的数提取出来，乘以2的(位数-1)次方， 然后求和。 案例:请将0b1011转成十进制的数 0b1011 = 1*2的(1-1)次方+ 1 * 2的(2-1)次方+ 0 * 2的(3-1)次方+ 1* 2的(4-1)次方法= 1 + 2 + 0+ 8= 11 2) 八进制转十进制 规则:从最低位(右边)开始，将每个位上的数提取出来，乘以8的(位数-1)次方, 然后求和。 案例:请将0234转成十进制的数 0234= 4*8^0+3*8^1+2*8^2-4+ 24+128= 156 3) 十六进制转十进制 规则：从最低位(右边)开始，将每个位上的数提取出来，乘以 16 的(位数-1)次方，然后求和。 案例：请将 0x23A 转成十进制的数 0x23A= 10 * 16^0 + 3 * 16 ^ 1 + 2 * 16^2 = 10 + 48 + 512 = 570 课堂练习：请将 0b110001100 转成 十进制 02456 转成十进制 0xA45 转成十进制 第二组： 4) 十进制转二进制 规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。 案例：请将 34 转成二进制 = 0B00100010 5) 十进制转八进制 规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。 案例：请将 131 转成八进制 =&gt; 0203 6) 十进制转十六进制 第三组 7) 二进制转八进制 规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。 案例：请将 ob11010101 转成八进制 ob11(3)010(2)101(5) =&gt; 0325 8) 二进制转十六进制 规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。 案例：请将 ob11010101 转成十六进制 ob1101(D)0101(5) = 0xD5 课堂练习：请将 0b11100101 转成 八进制 0b1110010110 转成 十六进制 第四组 9) 八进制转二进制 规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。 案例：请将 0237 转成二进制 02(010)3(011)7(111) = 0b10011111 10) 十六进制转二进制 规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。 案例：请将 0x23B 转成二进制 0x2(0010)3(0011)B(1011) = 0b001000111011 练习：请将 01230 转成 二进制 0xAB29 转成二进制 位运算1) 请看下面的代码段，回答 a,b,c,d,e 结果是多少? public static void maiin(String []args) { int a=1&gt;&gt;2; // 1 向右位移 2 位 int b=-1&gt;&gt;2;//算术右移 int c=1&lt;&lt;2;//算术左移 int d=-1&lt;&lt;2;// int e=3&gt;&gt;&gt;2;//无符号右移 //a,b,c,d,e 结果是多少 System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); System.out.println(&quot;c=&quot;+c); System.out.println(&quot;d=&quot;+d); System.out.println(&quot;e=&quot;+e); } 2) 请回答在 java 中，下面的表达式运算的结果是: (位操作)， 晚上练习 ~2=? // 按位取反 //推到 //1.得到2的源码 00000000 00000000 00000000 00000010 //2.~2操作 11111111 11111111 11111111 11111101 运算后的补码 //3.运算后的反码 11111111 11111111 11111111 11111100 //4.运算后的源码 10000000 00000000 00000000 00000011 =》-3 2&amp;3=?// 2 按位与 3 2|3=? //2按位或3 ~-5=? // 13&amp;7=? 5|4=? -3^3=?//^ 按位异或 二进制在运算中的说明 1.二进制是逢2进位的进位制，0、1是基本算符。 2.现代的电子计算机技术全部采用的是进制，因为它只使用0、1两个数字符号， 非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制 数来表示的。二进制(Binary) 数用0和1两个数字及其组合来表示任何数。进位 规则是&quot;逢2进1&quot;,数字1在不同的位上代表不同的值，按从右至左的次序，这个 值以二倍递增 原码、反码、补码(重点 难点) 原码，反码,补码的解释(背下来） 对于有符号的而言: 1.二进制的最高位是符号位: 0表示正数，1表示负数(老韩口诀: 0-&gt;0 1-&gt; -) 2.正数的原码，反码，补码都样(三码合一) 3.负数的反码=它的原码符号位不变，其它位取反(0-&gt;1,1-&gt;0) 4.负数的补码=它的反码+1，负数的反码=负数的补码- 1 5.0的反码，补码都是0 6. java没有无符号数，换言之，java中的数都是有符号的 7.在计算机运算的时候，都是以补码的方式来运算的 8.当我们看运算结果的时候，要看他的原码(重点) 位运算符 java 中有 7 个位运算(&amp;、|、^、~、&gt;&gt;、&lt;&lt;和 &gt;&gt;&gt;) 分别是按位与&amp;、按位或|、按位异或^ ,按位取反~ ,它们的运算规则是: 按位与&amp; ：两位全为1,结果为1，否则为0 按位或| ：两位有一个为1,结果为1,否则为0 按位异或^ : 两位一个为0,一个为1,结果为1,否则为0 按位取反~ : 0-&gt;1 ,1-&gt;0 比如: 2&amp;3=? ~-2 = ? ~2=? 2|3=? 2^3=? 还有 3 个位运算符 &gt;&gt;、&lt;&lt; 和 &gt;&gt;&gt; , 运算规则: 1. 算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 2. 算术左移 &lt;&lt;: 符号位不变,低位补 0 3. &gt;&gt;&gt; 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 4. 特别说明：没有 &lt;&lt;&lt; 符号 1) int a=1&gt;&gt;2; //1 =&gt; 00000001 =&gt; 00000000 本质 1 / 2 / 2 =0 2) int c=1&lt;&lt;2; //1 =&gt; 00000001 =&gt; 00000100 本质 1 * 2 * 2 = 4 六、程序控制结构在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句。 1) 顺序控制 2) 分支控制 3) 循环控制 顺序控制程序从上到下逐行执行，中间没有任何判断和跳转。 java中定义变量时采用向前引用： 即先定义后使用 分支控制 if-else分支控制 if-else 让程序有选择的的执行,分支控制有三种 1) 单分支 if 2) 双分支 if-else 3) 多分支 if-else if -....-else 单分支 基本语法 if(条件表达式){ ​ 执行代码块； } 当条件表达式为true是，就会执行{ }中的代码。如果为false，就不执行。 双分支 基本语法 if(条件表达式){ 执行代码块； }else{ 执行代码块2； } 当条件表达式成立时，即执行代码块1，否则执行代码块2 多分支 基本语法 if(条件表达式1){ 执行代码块； }else if(条件表达式1){ 执行代码块2； } ...... else{ 执行代码块n; } 如果没有else，如果所有条件表达式都不成立，则一个直行入口都没有 如果有else，如果所有条件表达式都不成立，则默认执行else代码块 嵌套分支在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支。建议: 不要超过 3 层 （可读性不好） 基本语法 if(){ if(){ //if-else... }else{ //if-else } } 应用案例参加歌手比赛，如果初赛成绩大于 8.0 进入决赛，否则提示淘汰。并且根据性别提示进入男子组或女子组。【可以让学员先练习下】, 输入成绩和性别，进行判断和输出信息。[NestedIf.java] 提示: double score; char gender; 接收字符: char gender = scanner.next().charAt(0) import java.util.Scanner; public class NestedIf { //编写一个 main 方法 public static void main(String[] args) { /* 参加歌手比赛，如果初赛成绩大于 8.0 进入决赛， 否则提示淘汰。并且根据性别提示进入男子组或女子组。 【可以让学员先练习下】, 输入成绩和性别，进行判断和输出信息。 [NestedIf.java] 提示: double score; char gender; 接收字符: char gender = scanner.next().charAt(0) */ //思路分析 //1. 创建 Scanner 对象，接收用户输入 //2. 接收 成绩保存到 double score //3. 使用 if-else 判断 如果初赛成绩大于 8.0 进入决赛，否则提示淘汰 //4. 如果进入到 决赛，再接收 char gender, 使用 if-else 输出信息 //代码实现 =&gt; 思路 --&gt; java 代码 Scanner myScanner = new Scanner(System.in); System.out.println(&quot;请输入该歌手的成绩&quot;); double score = myScanner.nextDouble(); if( score &gt; 8.0 ) { System.out.println(&quot;请输入性别&quot;); char gender = myScanner.next().charAt(0); if( gender == &#39;男&#39; ) { System.out.println(&quot;进入男子组&quot;); } else if(gender == &#39;女&#39;) { System.out.println(&quot;进入女子组&quot;); } else { System.out.println(&quot;你的性别有误，不能参加决赛~&quot;); } } else { System.out.println(&quot;sorry ,你被淘汰了~&quot;); } } } switch分支结构基本语法 switch(表达式){ case 常量1： 代码块1； break； case 常量2： 代码块2; break; ...... default: 代码块； break； } 1. switch关键字，表示swtich分支 2.表达式对应个值 3. case常量1 :当表达式的值等于常量1,就执行语句块1 4. break :表示退出swtich 5.如果和case常量1匹配，就执行语句块1,如果没有匹配，就继续匹配case常量2 6.如果一一个都没有匹配上，执行default switch 注意事项和细节讨论 1.表达式数据类型，应和case后的常量类型一致，或者是课一自动转成可以相互比较的类型，比如输入的是字符，而常量是int 2.switch（表达式）中表达式的返回值必须是:(byte,short,int,char,enum[枚举]，String) 3.case自居中的值必须是常量，而不能是变量 4.default字句是可选的，当没有匹配的case时，执行default 5.break语句用在执行完一个case分枝后使得程序跳出switch语句块，如果没有break，程序会顺序执行到switch结尾，除非遇到break； switch 和 if 的比较1) 如果 判断的具体数值不多，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可以使用，建议使用 swtich 语句。2) 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广 for 循环控制(!!!)基本语法 for(循环变量初始化；循环条件；循环变量迭代){ 循环操作(可以多条语句)； } 1. for 关键字，表示循环控制 2. for 有四要素: (1)循环变量初始化(2)循环条件(3)循环操作(4)循环变量迭代 3. 循环操作 , 这里可以有多条语句，也就是我们要循环执行的代码 4. 如果 循环操作(语句) 只有一条语句，可以省略 {}, 建议不要省略 public class 惩罚口诀表 { public static void main(String[] args) { for (int i= 1; i &lt; 10; i++) { for (int j = 1; j &lt;=i; j++) { System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\\t&quot;); } System.out.println(); } } } 注意事项和细节说明 1) 循环条件是返回一个布尔值的表达式 2) for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。 3) 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开。 while 循环控制基本语法 while(循环条件){ 循环体(语句)； 循环变量迭代； } 注意事项和细节说明 1) 循环条件是返回一个布尔值的表达式 2) while 循环是先判断再执行语句 do..while 循环控制基本语法 循环变量初始化; do{ 循环体( 语句); 循环变量迭代; }while(循环条件); 1. do while 是关键字 1. 也有循环四要素, 只是位置不一样 2. 先执行，再判断，也就是说，一定会至少执行一次 3. 最后 有一个 分号 ; 注意事项和细节说明 1) 循环条件是返回一个布尔值的表达式 2) do..while 循环是先执行，再判断， 因此它至少执行一次 多重循环控制(难点! 重点!) 介绍 1) 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。 【建议一般使用两层，最多不要超过 3 层, 否则，代码的可读性很差】 2) 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。 3) 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。 多重循环执行步骤分析： 请分析 下面的多重循环执行步骤, 并写出输出 =&gt; 内存分析法 //双层 for MulFor.java for(int i = 0; i &lt; 2; i++) { //先思考 for( int j = 0; j &lt; 3; j++) { System.out.println(&quot;i=&quot; + i + j=&quot; + j); } } 跳转控制语句-break基本语法： { …… break; …… } break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for , while , do-while]中。 跳转控制语句-continue基本语法： { …… continue; …… } 1) continue 语句用于结束本次循环， 继续执行下一次循环。 2) continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样. 跳转控制语句-returnreturn的常用作用有以下两种: 第一种用法是，方法的结束。 比如当代码执行到某个地方会出现几种结果，然后其中一种结果就不能执行后续代码，这时候在那里加上一个“return;”就可以终止后面的代码执行。 return 使用在方法，表示跳出所在的方法 。 第二种是返回方法指定类型的值（这个值总是确定的），也可以是对象 public string functionTest(){ return a; } 那么这个方法被调用之后就会返回一个值为abc的字符串， JavaAPI 文档1. API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接 口(java提供的类还有相关的方法)。中文在线文档: https://www.matools.com 2. Java语言提供了大量的基础类，因此Oracle公司也为这些基础类提供了相应的API文档，用于告诉 开发者如何使用这些类，以及这些类里包含的方法。 3. Java类的组织形式[java类的组织形式] 4.举例说明如何使用ArrayList类有哪些方法. 安包&gt;类-&gt;方法 直接索引. Math ASCII 码介绍(了解)ASCII码:上个世纪60年代，美国制定了一套字符编码(使用个字节)， 对英语字 符与二进制位之间的关系，做了统规定，这被称为ASCI码. ASCI码共规走 了128个字符的编码，只占甩了一个字节的后面7位，最前面的1位统规定为0。 特别提示:一个学书可以表示256个学符，ASCII码只用了128个字符 2.看完整的ASCII码表 3.缺点:不能表示所有字符。 Unicode 编码介绍(了解)1. Unicode的好处: 一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独 -无二的编码，使用Unicode没有乱码的问题。 2. Unicode 的缺点:一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。 3.2的1 6次方是65536,所以最多编码是65536个字符。 4.编码0-127的字符是与ASCII的编码样比如&#39;a&#39; 在ASCII码是0x61，在unicode码是 0x0061,都对应97.因此Unicode码兼容ASCII码. UTF-8 编码介绍(了解)1. UTF-8是在互联网上使用最广的一种Unicode的实现方式(改进) 2. UTF-8 是一种变长的编码方式。它可以使用1-6个字节表示个符号，根据不 同的符号而变化字节长度。 3.使用大小可变的编码字母占1个字节，汉字占3个字节","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"String","slug":"String","date":"2022-03-10T02:02:08.797Z","updated":"2022-03-10T02:03:32.550Z","comments":true,"path":"2022/03/10/String/","link":"","permalink":"/2022/03/10/String/","excerpt":"","text":"String类：一.常用方法 package com.test03; /** * Settings-Editor-File and Code Templates */ public class StringTest { public static void main(String[] args) { //1. equals 前面已经讲过了. 比较内容是否相同，区分大小写 String str1 = &quot;hello&quot;; String str2 = &quot;Hello&quot;; System.out.println(str1.equals(str2));// // 2.equalsIgnoreCase 忽略大小写的判断内容是否相等 String username = &quot;johN&quot;; if (&quot;john&quot;.equalsIgnoreCase(username)) { System.out.println(&quot;Success!&quot;); } else { System.out.println(&quot;Failure!&quot;); } // 3.length 获取字符的个数，字符串的长度 System.out.println(&quot;韩顺平&quot;.length()); // 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1 String s1 = &quot;wer@terwe@g&quot;; int index = s1.indexOf(&#39;@&#39;); System.out.println(index);// 3 System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0 // 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1 s1 = &quot;wer@terwe@g@&quot;; index = s1.lastIndexOf(&#39;@&#39;); System.out.println(index);//11 System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4 // 6.substring 截取指定范围的子串 String name = &quot;hello,张三&quot;; //下面 name.substring(6) 从索引 6 开始截取后面所有的内容 System.out.println(name.substring(6));//截取后面的字符 //name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置 System.out.println(name.substring(2,5));//llo } } package com.test03; /** * Settings-Editor-File and Code Templates */ public class StringTest02 { public static void main(String[] args) { // 1.toUpperCase 转换成大写 String s = &quot;heLLo&quot;; System.out.println(s.toUpperCase());//HELLO // 2.toLowerCase System.out.println(s.toLowerCase());//hello // 3.concat 拼接字符串 String s1 = &quot;宝玉&quot;; s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;); System.out.println(s1);//宝玉林黛玉薛宝钗 together // 4.replace 替换字符串中的字符 s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;; //在 s1 中，将 所有的 林黛玉 替换成薛宝钗 // s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响 String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;); System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉 System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉 // 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\\\等 String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;; // 1. 以 , 为标准对 poem 进行分割 , 返回一个数组 // 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \\ String[] split = poem.split(&quot;,&quot;); poem = &quot;E:\\\\aaa\\\\bbb&quot;; split = poem.split(&quot;\\\\\\\\&quot;); System.out.println(&quot;==分割后内容===&quot;); for (int i = 0; i &lt; split.length; i++) { System.out.println(split[i]); } // 6.toCharArray 转换成字符数组 s = &quot;happy&quot;; char[] chs = s.toCharArray(); for (int i = 0; i &lt; chs.length; i++) { System.out.println(chs[i]); } // 7.compareTo 比较两个字符串的大小，如果前者大， // 则返回正数，后者大，则返回负数，如果相等，返回 0 // (1) 如果长度相同，并且每个字符也相同，就返回 0 // (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小 // 就返回 if (c1 != c2) { // return c1 - c2; // } // (3) 如果前面的部分都相同，就返回 str1.len - str2.len String a = &quot;jcck&quot;;// len = 3 String b = &quot;jack&quot;;// len = 4 System.out.println(a.compareTo(b)); // 返回值是 &#39;c&#39; - &#39;a&#39; = 2 的值 // 8.format 格式字符串 /* 占位符有: * %s 字符串 %c 字符 %d 整型 %.2f 浮点型 * */ String name = &quot;john&quot;; int age = 10; double score = 56.857; char gender = &#39;男&#39;; //将所有的信息都拼接在一个字符串. String info = &quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！ &quot;; System.out.println(info); //1. %s , %d , %.2f %c 称为占位符 //2. 这些占位符由后面变量来替换 //3. %s 表示后面由 字符串来替换 //4. %d 是整数来替换 //5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理 //6. %c 使用 char 类型来替换 String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;; String info2 = String.format(formatStr, name, age, score, gender); System.out.println(&quot;info2=&quot; + info2); } } StringBuffer 类：public class StringBuffer01 { public static void main(String[] args) { //1. StringBuffer 的直接父类 是 AbstractStringBuilder //2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 //3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final // 该 value 数组存放 字符串内容，引出存放在堆中的 //4. StringBuffer 是一个 final 类，不能被继承 //5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除) // 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;); } } String VS StringBuffer1) String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址， 效率较低//private final char value[];2) StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高//char[] value; /这个放在堆 String 和 StringBuffer 相互转换 `javapublic class StringAndStringBuffer {public static void main(String[] args) {//看 String——&gt;StringBuffer String str = “hello tom”;//方式 1 使用构造器//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响StringBuffer stringBuffer = new StringBuffer(str);//方式 2 使用的是 append 方法StringBuffer stringBuffer1 = new StringBuffer();stringBuffer1 = stringBuffer1.append(str);//看看 StringBuffer -&gt;StringStringBuffer stringBuffer3 = new StringBuffer(“韩顺平教育”);//方式 1 使用 StringBuffer 提供的 toString 方法String s = stringBuffer3.toString();//方式 2: 使用构造器来搞定String s1 = new String(stringBuffer3);}}13.5.4 StringBuffer 类常见方法package com.hspedu.stringbuffer_; public class StringBufferMethod { public static void main(String[] args) { StringBuffer s = new StringBuffer(&quot;hello&quot;); //增 s.append(&#39;,&#39;);// &quot;hello,&quot; s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot; s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot; System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot; //删 /* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符 解读: 删除 11~14 的字符 [11, 14)*/s.delete(11, 14);System.out.println(s);//“hello,张三丰赵敏 true10.5”//改//，使用 周芷若 替换 索引 9-11 的字符 [9,11)s.replace(9, 11, “周芷若”);System.out.println(s);//“hello,张三丰周芷若 true10.5”//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1int indexOf = s.indexOf(“张三丰”);System.out.println(indexOf);//6//插 //，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移s.insert(9, “赵敏”);System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”//长度System.out.println(s.length());//22System.out.println(s);}} ` StringBuffer 类常见方法`java public class StringBufferMethod {public static void main(String[] args) {StringBuffer s = new StringBuffer(“hello”);//增s.append(‘,’);// “hello,”s.append(“张三丰”);//“hello,张三丰”s.append(“赵敏”).append(100).append(true).append(10.5);//“hello,张三丰赵敏 100true10.5”System.out.println(s);//“hello,张三丰赵敏 100true10.5”//删/* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符 解读: 删除 11~14 的字符 [11, 14)*/s.delete(11, 14);System.out.println(s);//“hello,张三丰赵敏 true10.5”//改//，使用 周芷若 替换 索引 9-11 的字符 [9,11)s.replace(9, 11, “周芷若”);System.out.println(s);//“hello,张三丰周芷若 true10.5”//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1int indexOf = s.indexOf(“张三丰”);System.out.println(indexOf);//6//插 //，在索引为 9 的位置插入 “赵敏”,原来索引为 9 的内容自动后移s.insert(9, “赵敏”);System.out.println(s);//“hello,张三丰赵敏周芷若 true10.5”//长度System.out.println(s.length());//22System.out.println(s);}}` StringBuffer 类测试题 1 StringBufferExercise01.javapublic class StringBufferExercise01 { public static void main(String[] args) { String str = null;// ok StringBuffer sb = new StringBuffer(); //ok sb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNull System.out.println(sb.length());//4 System.out.println(sb);//null 韩顺平学 循序渐进学 Java 零基础 第 561页 //下面的构造器，会抛出 NullpointerException StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16); System.out.println(sb1); } } public class StringBufferExercise02 { public static void main(String[] args) { /* 输入商品名称和商品价格，要求打印效果示例, 使用前面学习的方法完成： 商品名 商品价格 手机 123,564.59 //比如 价格 3,456,789.88 要求：价格的小数点前面每三位用逗号隔开, 在输出。 思路分析 1. 定义一个 Scanner 对象，接收用户输入的 价格(String) 2. 希望使用到 StringBuffer 的 insert ，需要将 String 转成 StringBuffer 3. 然后使用相关方法进行字符串的处理 代码实现 */ //new Scanner(System.in) String price = &quot;8123564.59&quot;; StringBuffer sb = new StringBuffer(price); //先完成一个最简单的实现 123,564.59 //找到小数点的索引，然后在该位置的前 3 位，插入,即可 // int i = sb.lastIndexOf(&quot;.&quot;); // sb = sb.insert(i - 3, &quot;,&quot;); //上面的两步需要做一个循环处理,才是正确的 for (int i = sb.lastIndexOf(&quot;.&quot;) - 3; i &gt; 0; i -= 3) { sb = sb.insert(i, &quot;,&quot;); } System.out.println(sb);//8,123,564.59 } } StringBuilder01 java1)一个可变的字符序列。此类提供一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类因为在大多数实现中，它比StringBuffer要快[后面测]。2)在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。 public class StringBuffer01 { public static void main(String[] args) { //1. StringBuffer 的直接父类 是 AbstractStringBuilder //2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化 //3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final // 该 value 数组存放 字符串内容，引出存放在堆中的 //4. StringBuffer 是一个 final 类，不能被继承 //5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除) // 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String StringBuffer stringBuffer = new StringBuffer(&quot;hello&quot;); } } public class StringBuilder01 { public static void main(String[] args) { //1. StringBuilder 继承 AbstractStringBuilder 类 //2. 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件) //3. StringBuilder 是 final 类, 不能被继承 //4. StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value; // 因此，字符序列是堆中 //5. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用 // StringBuilder StringBuilder stringBuilder = new StringBuilder(); } } String、StringBuffer 和 StringBuilder 的比较 1) StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样2) String: 不可变字符序列，效率低,但是复用率高。3) StringBuffer: 可变字符序列、效率较高(增删)、线程安全，看源码4) StringBuilder: 可变字符序列、效率最高、线程不安全5) String使用注意说明:string s= “a”; //创建了一个字符串s += “b”; //实际上原来的” a”字符串对象已经丢弃了，现在又产生了一个字符I串s+”b” (也就是”ab”)。 如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=&gt;结论:如果我们对String做大量修改，不要使用String String、StringBuffer 和 StringBuilder 的选择使用的原则， 结论:1.如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder2.如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder3.如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer4.如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等StringBuilder的方法使用和StringBuffer一样 Math 类Math 类常见方法public class MathMethod { public static void main(String[] args) { //看看 Math 常用的方法(静态方法) //1.abs 绝对值 int abs = Math.abs(-9); System.out.println(abs);//9 //2.pow 求幂 double pow = Math.pow(2, 4);//2 的 4 次方 System.out.println(pow);//16 //3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double); double ceil = Math.ceil(3.9); System.out.println(ceil);//4.0 //4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double) double floor = Math.floor(4.001); System.out.println(floor);//4.0 //5.round 四舍五入 Math.floor(该参数+0.5) long round = Math.round(5.51); System.out.println(round);//6 //6.sqrt 求开方 double sqrt = Math.sqrt(9.0); System.out.println(sqrt);//3.0 //7.random 求随机数 // random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数 // 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7 // 即返回一个数 x 2 &lt;= x &lt;= 7 // Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a // (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) ) // (2) 使用具体的数给小伙伴介绍 a = 2 b = 7 // (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6) // Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数 // 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数 // (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7 // (3) 公式就是 (int)(a + Math.random() * (b-a +1) ) for(int i = 0; i &lt; 100; i++) { System.out.println((int)(2 + Math.random() * (7 - 2 + 1))); } //max , min 返回最大值和最小值 int min = Math.min(1, 9); int max = Math.max(45, 90); System.out.println(&quot;min=&quot; + min); System.out.println(&quot;max=&quot; + max); } } Arrays 类Arrays 类常见方法应用public class ArraysMethod01 { public static void main(String[] args) { Integer[] integers = {1, 20, 90}; //遍历数组 // for(int i = 0; i &lt; integers.length; i++) { // System.out.println(integers[i]); // } //直接使用 Arrays.toString 方法，显示数组 // System.out.println(Arrays.toString(integers));// //演示 sort 方法的使用 Integer arr[] = {1, -1, 7, 0, 89}; //进行排序 //1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序 //2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr //3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序 //4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr // (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法 //5. 先演示效果，再解释 //6. 这里体现了接口编程的方式 , 看看源码，就明白 // 源码分析 //(1)Arrays.sort(arr, new Comparator() //(2) 最终到 TimSort 类的 private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, // Comparator&lt;? super T&gt; c)() //(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的 // 匿名内部类的 compare () // while (left &lt; right) { // int mid = (left + right) &gt;&gt;&gt; 1; // if (c.compare(pivot, a[mid]) &lt; 0) // right = mid; // else // left = mid + 1; // } //(4) new Comparator() { // @Override // public int compare(Object o1, Object o2) { // Integer i1 = (Integer) o1; // Integer i2 = (Integer) o2; // return i2 - i1; // } // } //(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0 // 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用 // 将来的底层框架和源码的使用方式，会非常常见 //Arrays.sort(arr); // 默认排序方法 //定制排序 Arrays.sort(arr, new Comparator() { @Override public int compare(Object o1, Object o2) { Integer i1 = (Integer) o1; Integer i2 = (Integer) o2; return i2 - i1; } }); System.out.println(&quot;===排序后===&quot;); System.out.println(Arrays.toString(arr));// } } public class ArraysSortCustom { public static void main(String[] args) { int[] arr = {1, -1, 8, 0, 20}; //bubble01(arr); bubble02(arr, new Comparator() { @Override public int compare(Object o1, Object o2) { int i1 = (Integer) o1; int i2 = (Integer) o2; return i2 - i1;// return i2 - i1; } }); System.out.println(&quot;==定制排序后的情况==&quot;); System.out.println(Arrays.toString(arr)); } //使用冒泡完成排序 public static void bubble01(int[] arr) { int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { //从小到大 if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //结合冒泡 + 定制 public static void bubble02(int[] arr, Comparator c) { int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { //数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定 if (c.compare(arr[j], arr[j + 1]) &gt; 0) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } } `javapackage com.hspedu.arrays_;import java.util.Arrays;import java.util.List; public class ArraysMethod02 { public static void main(String[] args) { Integer[] arr = {1, 2, 90, 123, 567}; // binarySearch 通过二分搜索法进行查找，要求必须排好 //1. 使用 binarySearch 二叉查找 //2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch //3. 如果数组中不存在该元素，就返回 return -(low + 1); // key not found. int index =Arrays.binarySearch(arr, 567); System.out.println(&quot;index=&quot; + index); //copyOf 数组元素的复制 //1. 从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中 //2. 如果拷贝的长度 &gt; arr.length 就在新数组的后面 增加 null //3. 如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException //4. 该方法的底层使用的是 System.arraycopy() Integer[] newArr =Arrays.copyOf(arr, arr.length); System.out.println(&quot;==拷贝执行完毕后==&quot;); System.out.println(Arrays.toString(newArr)); //ill 数组元素的填充 Integer[] num = new Integer[]{9,3,2}; //1. 使用 99 去填充 num 数组，可以理解成是替换原理的元素 Arrays.fill(num, 99); System.out.println(&quot;==num 数组填充后==&quot;); System.out.println(Arrays.toString(num)); //equals 比较两个数组元素内容是否完全一致 Integer[] arr2 = {1, 2, 90, 123}; //1. 如果 arr 和 arr2 数组的元素一样，则方法 true; //2. 如果不是完全一样，就返回 false boolean equals =Arrays.equals(arr, arr2); System.out.println(&quot;equals=&quot; + equals); //asList 将一组值，转换成 list //1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合 //2. 返回的 asList 编译类型 List(接口) //3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的 // 静态内部类 private static class ArrayList&lt;E&gt; extendsAbstractList&lt;E&gt; // implements RandomAccess, java.io.Serializable List asList =Arrays.asList(2,3,4,5,6,1); System.out.println(&quot;asList=&quot; + asList); System.out.println(&quot;asList 的运行类型&quot; + asList.getClass()); } } ### date日期类 Date:精确到毫秒，代表特定的瞬间 2) SimpleDateFormat:格式和解析日期的类 SimpleDateFormat格式化和解析日期的具 体类。它允许进行格式化(日期-&gt;文本) 解析(文本-&gt;日期)和规范化. | 3) 应用实例Date java 2) //1. Calendar 是一个抽象类， 并且构造器是 private//2. 可以通过 getInstance() 来获取实例//3. 提供大量的方法和字段提供给程序员 //4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAYCalendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由System.out.println(“c=” + c);//2.获取日历对象的某个日历字段System.out.println(“年：” + c.get(Calendar.YEAR));// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号System.out.println(“月：” + (c.get(Calendar.MONTH) + 1));System.out.println(“日：” + c.get(Calendar.DAY_OF_MONTH));System.out.println(“小时：” + c.get(Calendar.HOUR));System.out.println(“分钟：” + c.get(Calendar.MINUTE));System.out.println(“秒：” + c.get(Calendar.SECOND));//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示System.out.println(c.get(Calendar.YEAR) + “-“ + (c.get(Calendar.MONTH) + 1) + “-“ +c.get(Calendar.DAY_OF_MONTH) +“ “ + c.get(Calendar.HOUR_OF_DAY) + “:” + c.get(Calendar.MINUTE) + “:” + c.get(Calendar.SECOND) );}} #### 第三代日期类 //1. 使用 now() 返回表示当前日期时间的 对象LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()System.out.println(ldt);//2. 使用 DateTimeFormatter 对象来进行格式化// 创建 DateTimeFormatter 对象DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”);String format = dateTimeFormatter.format(ldt);System.out.println(“格式化的日期=” + format);System.out.println(“年=” + ldt.getYear());System.out.println(“月=” + ldt.getMonth());System.out.println(“月=” + ldt.getMonthValue());System.out.println(“日=” + ldt.getDayOfMonth());System.out.println(“时=” + ldt.getHour());System.out.println(“分=” + ldt.getMinute());System.out.println(“秒=” + ldt.getSecond());LocalDate now = LocalDate.now(); //可以获取年月日 LocalTime now2 = LocalTime.now();//获取到时分秒//提供 plus 和 minus 方法可以对当前时间进行加或者减//看看 890 天后，是什么时候 把 年月日-时分秒LocalDateTime localDateTime = ldt.plusDays(890);System.out.println(“890 天后=” + dateTimeFormatter.format(localDateTime));//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出LocalDateTime localDateTime2 = ldt.minusMinutes(3456);System.out.println(“3456 分钟前 日期=” + dateTimeFormatter.format(localDateTime2));}} #### 时间戳 //1.通过 静态方法 now() 获取表示当前时间戳的对象Instant now = Instant.now();System.out.println(now);//2. 通过 from 可以把 Instant 转成 DateDate date = Date.from(now); //3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象Instant instant = date.toInstant();}} #### 数组 1)长度开始时必须指定，而且一旦指定，不能正改2)保存的必须为同一类型的元素3)使用数组进行增加/删除元素的示意代码-比较麻烦 #### 集合 1)可以动态保存任意多个对象，使用比较方便!2)提供了一系列方便的操作对象的方法: add. remove. set, get等3)使用集合添加，删除新元素的示意代码简洁了 集合的框架体系 Java 的集合类很多，主要分为两大类，如图 ：[背下来] Collection_.java //1. 集合主要是两组(单列集合 , 双列集合) //2. Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合 //3. Map 接口的实现子类 是双列集合，存放的 K-V ![image-20220216112130181](C:\\Users\\张\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220216112130181.png) ![image-20220216112134559](C:\\Users\\张\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220216112134559.png) ##### Collection 接口和常用方法 1) collection实现子类可以存放多个元素，每个元素可以是Object 2)有些Collection的实现类， 可以存放重复的元素，有些不可以 3)有些Collection的实现类， 有些是有序的(List),有些不是有序(Set) 4) Collection接口没有直接的实现子类，是通过它的子接口Set和List来 实现的 collection 接口常用方法,以实现子类 ArrayList List list = newArrayList(); // add:添加单个元素 remove:删除指定元素 contains:查找元素是否存在 size:获取元素个数 isEmpty:判断是否为空 clear:清空 addAll:添加多个元素 containsAll:查找多个元素是否都存在 removeAll：删除多个元素 ##### Collection 接口遍历元素方式 1-使用 Iterator(迭代器) 1) lterator对象称为迭代器，主要用于遍历Collection集合中的元案。 2)所有实现了Collection接口的集合类都有一个iterator(方法， 用以返回 一个实现了 lterator接口的对象，即可以返回一个迭代器。 3) Iterator的结构.[看-张图] 4) Iterator仅用于遍历集合，Iterator 本身并不存放对象。 迭代器的执行原理Iterator iterator = oll.iterator0; //得到个集合的迭代器//hasNext():判断是否还有下一个元素while(iterator.hasNextO{//next作用:1.下移2.将下移以后集合位置.上的元素返回System. out.println(iterator.next0); 快速生成 while =&gt; itit//显示所有的快捷键的的快捷键 ctrl + j ##### Collection 接口遍历对象方式 2-for 循环增强 增强for循环， 可以代替iterator迭代器，特点:增强for就是简化版的iterat 本质样。只能用于遍历集合或数组。 快捷建大寫 I &gt; 基本语法for(元素类型元素名:集合名或数组名) {访问元素案例演示(遍历Book,并使用Debug源码来证明)CollectionForjavafor (Object object: col) {System. outprintln(object);` List 接口和常用方法 /1. List 集合类中元素有序(即添加顺序和取出顺序一致)、且可重复 [案例] List list = newArrayList(); list.add(&quot;jack&quot;); list.add(&quot;tom&quot;); list.add(&quot;mary&quot;); list.add(&quot;hsp&quot;); /2. List 集合中的每个元素都有其对应的顺序索引，即支持索引 // 索引是从 0 开始的 System.out.println(list.get(3)); public static void main(String[] args) { List list = newArrayList(); list.add(&quot;张三丰&quot;); list.add(&quot;贾宝玉&quot;); // void add(int index, Object ele):在 index 位置插入 ele 元素 //在 index = 1 的位置插入一个对象 list.add(1, &quot;啊啊啊&quot;); System.out.println(&quot;list=&quot; + list); // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来 List list2 = newArrayList(); list2.add(&quot;jack&quot;); list2.add(&quot;tom&quot;); list.addAll(1, list2); System.out.println(&quot;list=&quot; + list); // Object get(int index):获取指定 index 位置的元素 // int indexOf(Object obj):返回 obj 在集合中首次出现的位置 System.out.println(list.indexOf(&quot;tom&quot;));//2 // int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置 list.add(&quot;啊啊啊&quot;); System.out.println(&quot;list=&quot; + list); System.out.println(list.lastIndexOf(&quot;啊啊啊&quot;)); // Object remove(int index):移除指定 index 位置的元素，并返回此元素 list.remove(0); System.out.println(&quot;list=&quot; + list); // Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;); System.out.println(&quot;list=&quot; + list); // List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合 // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex List returnlist = list.subList(0, 2); System.out.println(&quot;returnlist=&quot; + returnlist); } }","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]},{"title":"练习","slug":"基础语法","date":"2022-03-10T02:02:08.773Z","updated":"2022-03-10T02:07:20.279Z","comments":true,"path":"2022/03/10/基础语法/","link":"","permalink":"/2022/03/10/基础语法/","excerpt":"","text":"方法递归调用(非常非常重要，比较难)基本介绍简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变得简洁 递归能解决什么问题?列举两个小案例,来帮助大家理解递归调用机制 打印问题 阶乘问题代码 public class Recursion01 { //编写一个 main 方法 public static void main(String[] args) { T t1 = new T(); t1.test(4);//输出什么？ n=2 n=3 n=4 int res = t1.factorial(5); System.out.println(&quot;5 的阶乘 res =&quot; + res); } } class T { //分析 public void test(int n) { if (n &gt; 2) { test(n - 1); } System.out.println(&quot;n=&quot; + n); } 韩顺平学 循序渐进学 Java 零基础第 220页 //factorial 阶乘 public int factorial(int n) { if (n == 1) { return 1; } else { return factorial(n - 1) * n; } } } 代码 public class RecursionExercise01 { //编写一个 main 方法 public static void main(String[] args) { T t1 = new T(); // int n = 7; // int res = t1.fibonacci(n); // if(res != -1) { // System.out.println(&quot;当 n=&quot;+ n +&quot; 对应的斐波那契数=&quot; + res); // } // //桃子问题 int day = 0; int peachNum = t1.peach(day); if(peachNum != -1) { System.out.println(&quot;第 &quot; + day + &quot;天有&quot; + peachNum + &quot;个桃子&quot;); } } } class T { /* 请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的值是多 思路分析 1. 当 n = 1 斐波那契数 是 1 2. 当 n = 2 斐波那契数 是 1 3. 当 n &gt;= 3 斐波那契数 是前两个数的和 4. 这里就是一个递归的思路 */ public int fibonacci(int n) { if( n &gt;= 1) { if( n == 1 || n == 2) { return 1; } else { return fibonacci(n-1) + fibonacci(n-2); } } else { System.out.println(&quot;要求输入的 n&gt;=1 的整数&quot;); return -1; } } 猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时，想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子？思路分析 逆推 day = 10 时 有 1 个桃子 day = 9 时 有 (day10 + 1) * 2 = 4 day = 8 时 有 (day9 + 1) * 2 = 10 规律就是 前一天的桃子 = (后一天的桃子 + 1) *2//就是我们的能力 递归*/ public int peach(int day) { if(day == 10) {//第 10 天，只有 1 个桃 return 1; } else if ( day &gt;= 1 &amp;&amp; day &lt;=9 ) { return (peach(day + 1) + 1) * 2;//规则，自己要想 } else { System.out.println(&quot;day 在 1-10&quot;); return -1; } } } 数字迷宫找出路package com; public class MIGong { public static void main(String[] args) { // 创建明迷宫 // 0表示路径 1表示障碍 int[][] map=new int [18][17]; for (int i = 0; i &lt; 17; i++) { map[0][i]=1; map[17][i]=1; } for (int i = 0; i &lt; 18; i++) { map[i][0]=1; map[i][16]=1; } map[3][4]=1; map[3][5]=1; map[3][6]=1; map[3][7]=1; map[4][4]=1; map[5][4]=1; map[2][1]=1; map[2][2]=1; map[3][2]=1; map[5][3]=1; map[16][15]=3; Te te = new Te(); te.findWay(map,1,1); System.out.println(&quot;======招錄情況=======&quot;); //输出地图 System.out.println(&quot;======地图======&quot;); for (int i = 0; i &lt; map.length; i++) { for (int j = 0; j &lt; map[i].length; j++) { System.out.print(map[i][j]+&quot; &quot;); } System.out.println(); } } } class Te { public boolean findWay(int[][] map,int i,int j){ // int a[][]=map[1][1]; if (map[15][14]==2){//説明找到路 return true; }else { if (map[i][j]==0){ map[i][j]=2; if (findWay(map,i+1,j)){ return true; }else if (findWay(map,i,j+1)){ return true; }else if (findWay(map, i-1, j)){ return true; }else if (findWay(map, i, j-1)){ return true; }else { map[i][j]=3; return false; } } return false; } } }","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]},{"title":"Nacos安装","slug":"Nacos安装指南","date":"2022-03-10T01:29:35.424Z","updated":"2022-03-10T01:58:43.367Z","comments":true,"path":"2022/03/10/Nacos安装指南/","link":"","permalink":"/2022/03/10/Nacos安装指南/","excerpt":"","text":"Nacos安装指南1.Windows安装开发阶段采用单机安装即可。 1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码： GitHub主页：https://github.com/alibaba/nacos GitHub的Release下载页：https://github.com/alibaba/nacos/releases 如图： 本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包： windows版本使用nacos-server-1.4.1.zip包即可。 1.2.解压将这个包解压到任意非中文目录下，如图： 目录说明： bin：启动脚本 conf：配置文件 1.3.端口配置Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。 如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口： 修改其中的内容： 1.4.启动启动非常简单，进入bin目录，结构如下： 然后执行命令即可： windows命令： startup.cmd -m standalone 执行后的效果如图： 1.5.访问在浏览器输入地址：http://127.0.0.1:8848/nacos即可： 默认的账号和密码都是nacos，进入后： 2.Linux安装Linux或者Mac安装方式与Windows类似。 2.1.安装JDKNacos依赖于JDK运行，索引Linux上也需要安装JDK才行。 上传jdk安装包： 上传到某个目录，例如：/usr/local/ 然后解压缩： tar -xvf jdk-8u144-linux-x64.tar.gz 然后重命名为java 配置环境变量： export JAVA_HOME=/usr/local/java export PATH=$PATH:$JAVA_HOME/bin 设置环境变量： source /etc/profile 2.2.上传安装包如图： 也可以直接使用课前资料中的tar.gz： 上传到Linux服务器的某个目录，例如/usr/local/src目录下： 2.3.解压命令解压缩安装包： tar -xvf nacos-server-1.4.1.tar.gz 然后删除安装包： rm -rf nacos-server-1.4.1.tar.gz 目录中最终样式： 目录内部： 2.4.端口配置与windows中类似 2.5.启动在nacos/bin目录中，输入命令启动Nacos： sh startup.sh -m standalone 3.Nacos的依赖父工程： &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 客户端： &lt;!-- nacos客户端依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"Docker介绍及使用","slug":"1.1.什么是Docker","date":"2022-03-10T01:27:18.470Z","updated":"2022-03-10T01:28:24.578Z","comments":true,"path":"2022/03/10/1.1.什么是Docker/","link":"","permalink":"/2022/03/10/1.1.什么是Docker/","excerpt":"","text":"1.1.什么是Docker微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图： 对比来看： 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 1.3.Docker架构1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry 1.4.安装Docker企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。 2.Docker的基本操作2.1.镜像操作2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 2.1.2.镜像命令常见的镜像操作命令 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： docker save --help 命令格式： docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： docker save -o nginx.tar nginx:latest 3）使用docker load加载镜像 先删除本地的nginx镜像： docker rmi nginx:latest 然后运行命令，加载本地文件： docker load -i nginx.tar","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"安装Docker","slug":"安装Docker","date":"2022-03-09T12:58:01.864Z","updated":"2022-03-10T01:28:20.740Z","comments":true,"path":"2022/03/09/安装Docker/","link":"","permalink":"/2022/03/09/安装Docker/","excerpt":"","text":"0.安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。 Docker CE 分为 stable test 和 nightly 三个更新频道。 官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。 1.CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。 1.1.卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 1.2.安装docker首先需要大家虚拟机联网，安装yum工具 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： # 设置docker镜像源 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i &#39;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repo yum makecache fast 然后输入命令： yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 1.3.启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！ # 关闭 systemctl stop firewalld # 禁止开机启动防火墙 systemctl disable firewalld 通过命令启动docker： systemctl start docker # 启动docker服务 systemctl stop docker # 停止docker服务 systemctl restart docker # 重启docker服务 然后输入命令，可以查看docker版本： docker -v 1.4.配置镜像加速docker官方镜像仓库网速较差，我们需要设置国内镜像服务： 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &quot;registry-mirrors&quot;:[&quot;https://n0dwemtq.mirror.aliyuncs.com&quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 2.CentOS7安装DockerCompose2.1.下载Linux下需要通过命令下载： # 安装 curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件： 上传到/usr/local/bin/目录也可以。 2.2.修改文件权限修改文件权限： # 修改权限 chmod +x /usr/local/bin/docker-compose 2.3.Base自动补全命令：# 补全命令 curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 如果这里出现错误，需要修改自己的hosts文件： echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts 3.Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。 官网地址：https://hub.docker.com/_/registry 3.1.简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。 搭建方式比较简单，命令如下： docker run -d \\ --restart=always \\ --name registry \\ -p 5000:5000 \\ -v registry-data:/var/lib/registry \\ registry 命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。 访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像 3.2.带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下： version: &#39;3.0&#39; services: registry: image: registry volumes: - ./registry-data:/var/lib/registry ui: image: joxit/docker-registry-ui:static ports: - 8080:80 environment: - REGISTRY_TITLE=传智教育私有仓库 - REGISTRY_URL=http://registry:5000 depends_on: - registry 3.3.配置Docker信任地址我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置： # 打开要修改的文件 vi /etc/docker/daemon.json # 添加内容： &quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;] # 重加载 systemctl daemon-reload # 重启docker systemctl restart docker","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"}],"keywords":[]},{"title":"Test","slug":"Test","date":"2021-12-12T14:16:01.000Z","updated":"2022-03-10T02:03:20.897Z","comments":true,"path":"2021/12/12/Test/","link":"","permalink":"/2021/12/12/Test/","excerpt":"","text":"前往github yml java public static void mian(String[] args){ }","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]},{"title":"elasticsearch","slug":"安装elasticsearch","date":"2021-12-12T14:16:01.000Z","updated":"2022-03-10T02:00:28.316Z","comments":true,"path":"2021/12/12/安装elasticsearch/","link":"","permalink":"/2021/12/12/安装elasticsearch/","excerpt":"","text":"安装elasticsearch1.部署单点es1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络： docker network create es-net 1.2.加载镜像大家将其上传到虚拟机中，然后运行命令加载即可： # 导入数据 docker load -i es.tar 同理还有kibana的tar包也需要这样做。 1.3.运行运行docker命令，部署单点es： docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\ elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 在浏览器中输入：http://192.168.150.101:9200 即可看到elasticsearch的响应结果 2.部署kibanakibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。 2.1.部署运行docker命令，部署kibana docker run -d \\ --name kibana \\ -e ELASTICSEARCH_HOSTS=http://es:9200 \\ --network=es-net \\ -p 5601:5601 \\ kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 kibana启动一般比较慢，需要多等待一会，可以通过命令： docker logs -f kibana 查看运行日志，查看是否成功。 在浏览器输入地址访问：http://192.168.150.101:5601，即可看到结果 2.2.DevToolskibana中提供了一个DevTools界面： 这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。 3.安装IK分词器(https://github.com/medcl/elasticsearch-analysis-ik) (https://github.com/medcl/elasticsearch-analysis-ik) 3.1.在线安装ik插件（较慢）# 进入容器内部 docker exec -it elasticsearch /bin/bash # 在线下载并安装 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip #退出 exit #重启容器 docker restart elasticsearch 3.2.离线安装ik插件（推荐）1）查看数据卷目录安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: docker volume inspect es-plugins 显示结果： [ { &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; } ] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data这个目录中。 2）解压缩分词器安装包需要资料中的ik分词器解压缩，重命名为ik 3）上传到es容器的插件数据卷中也就是/var/lib/docker/volumes/es-plugins/_data： 4）重启容器# 4、重启容器 docker restart es # 查看es日志 docker logs -f es 5）测试：IK分词器包含两种模式： ik_smart：最少切分 ik_max_word：最细切分 GET /_analyze { &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;程序员学习java&quot; } 3.3 扩展词词典词汇不断的更新，IK分词器提供了扩展词汇的功能。 1）打开IK分词器config目录： 2）在IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; &lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;/properties&gt; 3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改 4）重启elasticsearch docker restart es # 查看 日志 docker logs -f elasticsearch 日志中已经成功加载ext.dic配置文件 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 3.4 停用词词典1）IKAnalyzer.cfg.xml配置文件内容添加： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt; &lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典--&gt; &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典 *** 添加停用词词典--&gt; &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt; &lt;/properties&gt; 3）在 stopword.dic 添加停用词 4）重启elasticsearch # 重启服务 docker restart elasticsearch docker restart kibana # 查看 日志 docker logs -f elasticsearch 日志中已经成功加载stopword.dic配置文件 注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑 4.部署es集群部署es集群可以直接使用docker-compose来完成，不过要求你的Linux虚拟机至少有4G的内存空间 首先写一个docker-compose文件，内容如下： version: &#39;2.2&#39; services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data02:/usr/share/elasticsearch/data networks: - elastic es03: image: docker.elastic.co/elasticsearch/elasticsearch:7.12.1 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data03:/usr/share/elasticsearch/data networks: - elastic volumes: data01: driver: local data02: driver: local data03: driver: local networks: elastic: driver: bridge Run docker-compose to bring up the cluster: docker-compose up","categories":[],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[]}]}